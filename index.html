
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Chesterlee's Zen</title>
  <meta name="author" content="chesterlee">

  
  <meta name="description" content="本文是一个webView内存管理的trick，可以直接拿来用。
由于UIWebView的内容加载不受程序员直接控制，所以在UIWebView加载一些图片较多的网页时，如果图片较多，很容易就在网页读取阶段出现memory warning，而且当你把webview对象干掉时，内存依然不减。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://chesterlee.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Chesterlee's Zen" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Chesterlee's Zen</a></h1>
  
    <h2>Follow your heart and intuition</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://yahoo.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:chesterlee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/07/control-memory-in-uiwebview/">谈谈在UIWebView中的内存控制</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-10-07T21:05:05+08:00" pubdate data-updated="true">2014-10-07 21:05</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本文是一个webView内存管理的trick，可以直接拿来用。<br/>
由于UIWebView的内容加载不受程序员直接控制，所以在UIWebView加载一些图片较多的网页时，如果图片较多，很容易就在网页读取阶段出现memory warning，而且当你把webview对象干掉时，内存依然不减。如果不处理的话，程序就会被kill掉。如何处理呢，下面是几个tip可以让君尝试：</p>

<p>1、在每一次UIWebView读取页面结束后(Delegate)，调用UserDefault关闭缓存。代码：</p>

<pre><code>   - (void)webViewDidFinishLoad:(UIWebView *)webView 
   {
     [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:@"WebKitCacheModelPreferenceKey"];  
   } 
</code></pre>

<p>注意，不必担心这个WebKitCacheModelPreferenceKey会一直保持为0。因为每一次UIWebView加载页面的时候，都会把此值设置为1。</p>

<p>2、在离开webview的controller时，使用WebView加载nil的URL，并清理webview。</p>

<pre><code>-(void)viewDidDisappear:(BOOL)animated
{
  [super viewDidDisappear:animated];
  [self.webView loadRequest:nil];
  [self.webView removeFromSuperview];
  self.webView = nil;
  self.webView.delegate = nil;
  [self.webView stopLoading];
} 
</code></pre>

<p>3、在收到系统警告的时候，清理NSURLCache的CachedResponse。</p>

<pre><code>-(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  [self.navigationController setNavigationBarHidden:NO];
} 
</code></pre>

<p>trick结束:)。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/15/use-reactivecocoa/">使用ReactiveCocoa</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-15T22:21:07+08:00" pubdate data-updated="true">2014-09-15 22:21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>本篇的文章的目的很明确，就是要会使用RAC。这里对RAC的关键概念和行为做出较为清晰的说明，便于使用。</p>

<p>ReactiveCocoa衍生自FRP（响应链编程）的一种，它是用OC语言来描述FRP的一个框架。其根源可以追述到如下论坛：<a href= http://www.haskell.org/haskellwiki/Haskell>Haskell</a></p>

<p>要会使用RAC，首先要了解FRP，了解了响应链编程之后，才可以顺利的使用RAC。PS：其实回过头来思考，RAC使用的语言和方法并不重要，重要的是这些概念。如果后续要转入Swift的FRP，也是一样。</p>

<p>核心概念：</p>

<ul>
<li><p>信号(Signal)：信号是RAC的核心。我的理解是，在RAC的编码中，对于数据的反射式响应传输，都是以信号为基础来实现的。没有它，就没有响应式自动化。</p></li>
<li><p>订阅者 (Subscriber)：订阅者是使信号有效的一个重要角色。在FRP中，一个信号创建之后，是没有意义的，此时它不知道给谁传送数据，此时它是Cold的。而只有当他被一个或多个Subscriber订阅之后，信号接到事件源之后，就会触发响应，并发送数据给订阅者。</p></li>
</ul>


<p>通常的使用做法是：<br/>
a、使用一个既有信号(RAC已经给你wrapper好的Category)，然后使用匿名subscriber去做订阅行为，获取到next送来的值，或者error、completed的block，来做相应的业务逻辑操作。<br/>
b、如果自己要自定义信号，则需要通过create信号的方式，建立一个信号，在这个信号中执行数据获取、异步计算等操作，并在信号中发送sendNext、sendCompleted或sendError等数据或行为。注意，在sendNext中发送的数据，就是subscriber接到的数据。</p>

<p>另外，对于FRP而言，最为重要的就是信号和信号之间的关系：filter、flattenMap、CombineLatest、takeUntil、then等处理。下面简要说明下：</p>

<ul>
<li>filter：信号过滤，用于判断信号返回值的业务合法性。只有合法的信号，才可以被继续向下输送。</li>
<li>flattenMap(Map)：信号映射，可以将信号的发送过来的值重新计算，并以一个新值发送出去。</li>
<li>CombineLatest：是将多个信号合并为一个信号，但是这个信号承载的value是多个信号返回的value。</li>
<li>takeUntil：一个信号是一直hot的，但是当另外一个信号有效时，它就会失效。</li>
<li>then：当某个信号结束后，可以用then来继续后续的wapper，返回或新生成一个新的signal，来继续操作。</li>
</ul>


<p>ReactiveCocoa还支持对系统Event、Notification、liftSelector、多线程、timer等处理。</p>

<p>我们可以看到，RAC可以在不影响原有业务逻辑的情况下，新增新的更复杂的业务逻辑。象积木一样不断积累和可扩展。而完全不必要地新增状态变量，让原有的代码发生更改。</p>

<p>本文只讲解比较关键的几个概念，详细的概念可以参看下面的文章，代码可以看看文中具体的使用也可以见<a href = https://github.com/chesterlee/UseRAC>UseRAC</a>中的代码。</p>

<p>文中的概念参考文章有：<br/>
1、<a href = http://www.infoq.com/cn/articles/functional-reactive-programming>函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a><br/>
2、<a href = https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa in github</a><br/>
3、<a href = http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/>Getting Started with ReactiveCocoa</a><br/>
4、<a href = http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1>MVVM Tutorial with ReactiveCocoa: Part &frac12;</a><br/>
5、<a href = http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2>MVVM Tutorial with ReactiveCocoa: Part 2/2 </a><br/>
6、<a href = http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html>ReactiveCocoa2实战</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/">谈谈iOS中的多屏幕显示</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-28T21:15:49+08:00" pubdate data-updated="true">2014-08-28 21:15</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近接到需要进行ipad通过Apple TV进行多屏显示的需求，所以研究了下，可以在自己App中对外部荧幕进行Mirror和Different Content的切换。如果你没玩过，实在是有些可惜，不妨往下看看：</p>

<h4>初步的概念</h4>

<p>iOS App中UIWindow通常包含了App的view，连通了当前的硬件设备。而和Window联系到一起的Screen代表了特定使用的显示内容。如果你的app允许用户使用外接显示器，我们就需要创建一个UIWIndow对象来管理对外界显示器的展示。</p>

<h4>要显示内容到外部屏幕？请添加UIWindow</h4>

<p>如果你要支持外屏显示，你需要建立另外一个不同的window对象，从而让这个UIWindow对象展示的内容投射放到外部设备上。默认你可以在两个window上展示相同的内容，因为他们默认是mirroring的。当然，你可以把这个mirroring关闭了，赋值为nil或初始化一个UIWIndow到上面去。</p>

<h4>Window和Screen的概念</h4>

<p>先说说UIWindow，它组合了所有需要显示的ViewTree，并负责对subview的展示，组织他们的继承体系，以及对它们的事件传递。通常每一个App都有一个window对象来展示app自己的UI（在iOS设备上）。如果有外部显示器链接到设备上，那么app就可以使用第二个window来进行大荧幕数据的展示。<br/>
再说说UIScreen对象，对于UIWindow而言，每一个UIWindow中有一个UIScreen对象。UIScreen对象抽象地描述了一个具体显示设备的信息：bounds、mode、brightness等。你也可以监听各种消息，比如连接上显示器了，断开显示器了，显示器亮度调整了等的消息。</p>

<h4>Window和Screen的其他用途</h4>

<p>1、通过UIWindow来调整Window的亮度。还有wantsSoftwareDimming等等。
2、通过UIScreen displayLinkWithTarget:selector: 接口来在runloop进行CoreAnimation每一帧的绘制，或使用OpenGL es直接绘制。</p>

<h4>StoryBoard做了点事情</h4>

<p>使用Storyboard，建立默认的VC。它就帮你做了下面几件事情：</p>

<ul>
<li>Instantiates a window. （初始化Window）</li>
<li>Loads the main storyboard and instantiates its initial view controller. (初始化Storyboard中的initial VC)</li>
<li>Assigns the new view controller to the window’s rootViewController property and then makes the window visible.(把initial VC作为UIWindow中的RootVC，然后让Window可见)</li>
</ul>


<h4>外接显示器的实际做法</h4>

<p>默认的iOS行为：Mirror。如果默认什么都不处理，那么对于一个App而言，它的内容是直接镜像到荧幕上的。除非你要显示和iOS设备荧幕不一样的内容，你可以这样做：</p>

<ul>
<li>程序一启动，就要检查外部显示器的存在。并且注册Screen的连接和断开连接的Notification。</li>
<li>当外部显示器可用了，无论是程序启动检测，还是收到Screen连接的Notification，你都要创建并且配置一个UIWindow给这个外部设备。</li>
<li>连接这个UIWindow和这个合适的UIScreen对象，展示第二个UIWindow，并更新。</li>
</ul>


<p>BTW：如果要开启镜像，请把多出来的UIWindow给干掉就好了。</p>

<h4>代码时间</h4>

<p>好，接下来是代码时间，上面3步的代码如下：<br/>
1、当外部设备Ready的时候，创建一个UIWindow匹配外部抽象的UIScreen对象。</p>

<pre><code>- (void)checkForExistingScreenAndInitializeIfPresent
{
   if ([[UIScreen screens] count] &gt; 1)
  {
     UIScreen *secondScreen = [[UIScreen screens] objectAtIndex:1];
     CGRect screenBounds = secondScreen.bounds;
     self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
     self.secondWindow.screen = secondScreen;
     self.secondWindow.hidden = NO;
  } 
}
</code></pre>

<p>注意：UIWindow最好先和UIScreen连接起来，然后再显示UIWindow的内容，最好不要先显示UIWindow的内容，再链接UIScreen。因为非常耗资源。</p>

<p>2、注册Screen的连接和断开事件</p>

<pre><code> - (void)setUpScreenConnectionNotificationHandlers
{
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    [center addObserver:self selector:@selector(handleScreenDidConnectNotification:) name:UIScreenDidConnectNotification object:nil];
    [center addObserver:self selector:@selector(handleScreenDidDisconnectNotification:)
}
</code></pre>

<p>3、处理断开和连接的事件</p>

<pre><code>- (void)handleScreenDidConnectNotification:(NSNotification*)aNotification
{
   UIScreen *newScreen = [aNotification object];
   CGRect screenBounds = newScreen.bounds;
   if (!self.secondWindow)
   {
    self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
    self.secondWindow.screen = newScreen;
   }
}

- (void)handleScreenDidDisconnectNotification:(NSNotification*)aNotification
{
  if (self.secondWindow)
  {
    // Hide and then delete the window.
    self.secondWindow.hidden = YES;
    self.secondWindow = nil;
  }
}
</code></pre>

<p> 以上代码也可以在水果文档的多屏编码指南中找到。其实这只是一个开始，表明自己Create的UIWindow可以以抽象的方式来在外部显示器上展示，至于不断添加业务逻辑，肯定需要更好的代码封装。最后说一句，水果文档建议在AppDelegate中进行Screen的监听，其实可以按需求来进行工作。大概就这样啦。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan/">谈谈iOS中的VCTransition发展</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-26T21:19:13+08:00" pubdate data-updated="true">2014-08-26 21:19</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>前言</h2>

<p>iOS的VCTransition一直是在跟着iOS不断变化着的，最大的感觉就是不断地解耦，动画之间VC的关联变得薄弱，或者都抽象到一个统一的位置，进行处理。下面都说下：</p>

<h4>Navigation、TabBar等切换</h4>

<p>  这个是最早(传统的)的VC风格了。比如使用如下代码：</p>

<pre><code>  -(IBAction)PushA:(id)sender 
  {  
     UIStoryboard *story = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
     AViewController *aVC = [story instantiateViewControllerWithIdentifier:@"AVCID"];  
     [self.navigationController pushViewController:aVC animated:YES]; 
  }
</code></pre>

<p>  这个方法是使用Navigation来管理VCs的一个Transition方式。比较简单，直接。但是耦合性比较大，在VC中必须知道自己要跳转到对应到VC，而且动画要写到对应的VC中，如果动画复杂，会很容易造成VC臃肿起来。</p>

<h4>VC容器的Transition</h4>

<p>由于iOS5.0后续版本新增了自定义的VC容器，那么从在容器中进行child vc之间到转场，会有专门的方法。比如如下代码:</p>

<pre><code>  [self transitionFromViewController:self.goodsCollectionVC
                  toViewController:self.mainPageVC
                          duration:SWITCH_VCS_TIME
                          options:UIViewAnimationOptionTransitionCrossDissolve animations:^{
                  // do animation things
} completion:^(BOOL finished) {
    // do animation completion things
}];
</code></pre>

<p>这个方法在容器中切换subVC比较方便，但是只实现了简单的Transition动画，并且依然是有耦合的。因为Container做动画的切换VC的时候，如果动画非常复杂，依然会有动画无法复用的状况。</p>

<h4>StoryBoard和Segue</h4>

<p>  这个是iOS5时提供的转场方式：通过在Storyboard中或代码中定义Push、Modal或 Custom segue，定义一个SegueID，然后需要做Transition的时候，去Perform一个Segue就可以了，代码如下：</p>

<pre><code>  [self performSegueWithIdentifier:@"PushSegueID" sender:self];  
</code></pre>

<p>在执行动画之前，自己的VC就要做些preparation可以在如下代码中调用</p>

<pre><code>  -(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender NS_AVAILABLE_IOS(5_0){} 
</code></pre>

<p>  特别需要说一下，如果动画处理复杂的，通过Custom Segue，就可以把动画挪到自定义segue中，降低sourceVC的代码量，动画也可以解耦甚至抽象。主要步骤就有两个：<br/>
  &ndash; 在Storybaord或代码中实例化自定义的segue。
  &ndash; 自定义Segue类复写perform方法。<br/>
  关键代码如下：</p>

<pre><code>   -(void)perform
   {
      id sourceVC = self.sourceViewController;
      id destVC = self.destinationViewController;
      //Do animation  
    }
</code></pre>

<p> segue 最关键的两个property，一个是sourceViewController，一个是destinationViewController，就实现一个动画而言，这两个变量就够了。</p>

<h4>iOS7的Transition</h4>

<p>iOS7提供了新的transition方式。默认提供了Present和Push的抽象动画，新增了percent的手势交互动画。例如，如果要自定义navigation push的动画就可以实现一个支持UIViewControllerAnimatedTransitioning的对象。在这个transition对象中，来设计自己的动画。和segue类似，代码可见：</p>

<pre><code>   -(void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
   {
        UIViewController *destController =  [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];  
        UIViewController *fromController =  [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
        UIView *containerView = [transitionContext containerView];  
        [containerView addSubview:destController.view];
   }
</code></pre>

<p>和Segue相同的是，都可以通过对象来获取Source和DestinationVC。不同的是，iOS7新提供的Transition提供了ContainerView，来做动画交互的容器。<br/>
对于外部而言，在代理中制定对应的Custom Transition对象即可使用他们了，可定制化更高：<br/>
比如在VC Controller中实例化对应的代理方法：</p>

<pre><code>   -(id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                               animationControllerForOperation:(UINavigationControllerOperation)operation
                                            fromViewController:(UIViewController *)fromVC
                                              toViewController:(UIViewController *)toVC
                                         {
                                            if (someCondition) 
                                            {
                                              _naviTransitioning.operation = operation;
                                              return  _naviTransitioning;
                                            }
                                            return nil;
                                          }
</code></pre>

<p>至于iOS7的UIPercentDrivenInteractiveTransition，这里不展开讲了，具体可以搜搜相关文档。<br/>
经过Transition的不断强化，iOS7新增的Transition，大大增强了动画的复用性，降低了耦合度，增加了交互性，给编码人员提供更多福利。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/25/iosshou-shi-he-uishi-jian-chuan-di-de-chong-chong-xi-jie/">iOS手势和UI事件传递的种种细节</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-25T20:03:53+08:00" pubdate data-updated="true">2014-08-25 20:03</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>做iOS交互，最为重要的就是UI的事件传递需要很清楚。当然也要包括各种&#8221;小&#8221;细节。
这里首先说说大的过程，也是UI事件传递的基本过程：当APP收到用户点击之后，就会做两个过程：</p>

<ul>
<li>1、遍历树，找哪个UIView是被Point击中。</li>
<li>2、回溯tree node，形成响应者链。剩下的就是UIEvent的传递了。</li>
</ul>


<p>现在让我们谈谈几个问题，一个View添加了Gesture了，那么在它之上的touches的回调会收到调用吗？一个view的superview的VC添加了手势，那么在该view中的touches会收到调用吗？如何正确地传递给superview相应touches调用？UITouch里面有什么东西？如果这些有些不太清楚，那么请往下看。</p>

<h4>几个不得不提的概念:</h4>

<ul>
<li>Touches began/Moved/Cancelled/touchesEnded是UIResponder的接口，用于接收触摸的各种事件。<strong>过程简述为UserTouch&mdash;>UIApplication&mdash;>UIWindow&mdash;>UIView</strong>。</li>
<li><strong>UITouch代表一个手指，从开始接触屏幕到离开屏幕的触碰描述数据</strong>。展开来说，UITouch包含了上一次手指的位置信息，当前的UITouch的状态TouchPhase，当前的时间戳以及UITouch要送往的那些以定义的手势。具体作用和关联，后面讲。</li>
<li>当发生了触摸时，UIEvent就会包含UITouch的数组，被App送到对应的Responder上（如果这个Responder书写了touchesBegan等UITouch的回调的话）。</li>
<li>UITouch的状态机有TouchPhaseBegan、Moved、Ended几个。当然，分别对应那几个回调。这里请注意，<strong>UITouch的状态机和手势的状态机如UIGestureRecognizerStateBegan，是完全不同的，千万不要混淆</strong>.</li>
<li><strong>Gesture的状态</strong>：单独Gesture(如Tap)是有识别状态的，一个叫Possible，一个叫Recognized，一个叫Failed。而连续Gesture(如Pinch)相比之下多了began、changed等状态。</li>
</ul>


<hr />

<h4>UITouch的发送机制：</h4>

<p>一句话：手势先于UIView获取Touch的响应权。详细说来：当对屏幕进行点击的时候，如前面所说，UITouch的对象会从UIApplication被依次传递，这里如果View或者其superview添加了Gesture。默认状况下：UITouch就会被送到这个Gesture上去识别，如果Gesture无法识别则会送UITouch对象点到的那个UIView上去做响应。</p>

<p>回答前两个问题：这个事件先发送到一个Gesture上，并不意味着会结束touches等的调用，这个调用只是delay了。所以，第一个问题，它的touches began会收到回调，它的superview及其VC都会收到touches began的回调。而且began，moved有可能还先于手势收到回调，原因是就是Gesture对UI事件调用的影响原则：</p>

<ul>
<li>如果在某个时刻，如果Gesture根据UITouch的变化识别出了自己的手势，把Possble状态跳到了Recognized状态。那么App将不会给对应的View或VC发送后续的UIEvent。转而，UITouch的事件将会没有走完，且会收到touches:Cancelled事件而不会收到touches:Ended事件。</li>
<li>如果整个过程中，Gesture都没有识别出自己的手势，那么它会设置自己的状态未Failed。那么这些UITouch对象会被转发给对应的UIView或VC。</li>
</ul>


<p>最后说说UItouches中包含了一个gestureRecognizers数组作用是什么呢，注意这个小过程：</p>

<ul>
<li>UITouch是通过touchesBegan、touchesMoved、touchesEnded等方法被送到对应的Gesture上的。UITouch其实也就是记录了被注册的Gesture对象的指针，这里就被传递到手势上了。</li>
<li>因此，在默认状况下，如果一个view注册了touchesBegan、它或它的superview注册了Gesture，touchesbegan会先于Gesgure收到UITouch。</li>
</ul>


<hr />

<h4>所以，在这里总结下，默认状况下手势是通过touchesBegan等事件传递的方式获取UITouch，并根据UITouch的变化进行了手势自身的判断，如果手势判断成功，手势自身的状态就会从Possible变为Recognized，从而阻止了touchesEnded的调用。但是在这个过程中，默认touchesBegan是先被目标view调用的。</h4>

<p>最后说说delaysTouchesBegan 和 delaysTouchesEnded</p>

<ul>
<li><strong>概念</strong>。这两个属性是手势的，默认delaysTouchesBegan为NO，delaysTouchesEnded为Yes。表示的涵义是：不延迟touchesBegan调用，目标View可以接到这些事件，而Delay TouchesEnded的调用。让手势获取最终的决定权。PS:他们的影响类似ScrollView中的delaysContentTouches变量，是否把延迟把UITouch传递给ScrollView中的subView。</li>
<li><strong>配置</strong>。你可以把delaysTouchesBegan开启，阻止touchesBegan调用，直接收到手势。但是这样会有时让用户感到UI失去响应。
delaysTouchesEnded也可以被设置为NO，如果这样的话当delaysTouchesBegan为NO的情况，UITouch就会被传递到目标UIView上，相当于:UIView自己接事件，而且手势也去接事件。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/24/ios7zhong-ui-trick/">edgesForExtendedLayout、automaticallyAdjustsScrollViewInsets和extendedLayoutIncludesOpaqueBars</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-24T23:58:15+08:00" pubdate data-updated="true">2014-08-24 23:58</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这几个属性值得写清楚，因为他们有组合起来使用的状况，有时候情况会变得较为复杂。</p>

<p>edgesForExtendedLayout：UIRectEdgeTop 延伸是会影响childviewcontroller的向上延伸的特点。（正确地说，是UINavigationController 作用所有的sub ViewController 中的向上延伸的特性。）如果edgesForExtendedLayout包含了UIRectEdgeTop，那么childVC的view会占据整个屏幕，反之，它会置于Navigationbar的offsetY下面。</p>

<p>automaticallyAdjustsScrollViewInsets：它的涵义是：如果UINavigationController或UIToolbarViewController的子View是Scrollview及其子类，在edgesForExtendedLayout含有top的状况下，会修改ScrollView的ContentInsect，来满足Scrollview的内容向上滑动时，statubar和navigation bar浮在其内容上。当然，如果edgesForExtendedLayout如果不含有top，那么就关闭了浮在navigation bar和statubar的特性，automaticallyAdjustsScrollViewInsets的作用也就失去意义了- &ndash;>此时NavigationController不会因为这个值是YES来设置scrollview的contentInsects。PS：（对挂接到一个view的tableview或scrollview是无效的。注意这里如果使用了childviewcontroller就可以验证这一点了。）</p>

<p>extendedLayoutIncludesOpaqueBars，这个属性指定了当Bar使用了不透明图片时，视图是否延伸至Bar所在区域，默认值时NO。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/15/tan-tan-ioszhong-de-nsurlprotocol/">谈谈iOS中的NSURLProtocol</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-15T10:23:37+08:00" pubdate data-updated="true">2014-08-15 10:23</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSURLProtocol是比较&#8221;小众&#8221;，但是能量极大的一个东东。在NSHipster中matt对其有详细介绍。<br/>
它就像在少林寺里，武功最高的，就是在一旁扫落叶的僧人，默默无闻，你一旦发现他，各种绝学就来了。<br/>
&ndash;_-扯远了，我们先看看它是什么，然后看看它能干什么。</p>

<p>1、它的概念：
它是一个抽象类，我们可以通过继承它来定义新的或已存在的URL加载行为。<br/>
2、就它的功效而言,它可以做各种hack的事情：^_^</p>

<ul>
<li>拦截获取图片的Request，然后自行加载自己的图片。</li>
<li>自己拦截特定Request，然后自己做签名，header修改。</li>
<li>过滤Response、Request中的敏感信息，当然也可以加上敏感信息-0-。</li>
<li>支持NSURLConnection的callback协议，可以对上层完全透明。</li>
</ul>


<p>3、怎么用？<br/>
只需要做两件事情： <br/>
a、子类化NSURLProtocol类，并注册。APP启动后，但做网络请求之前，就可以干这事情了。后续iOS必然是单例化你的类，然后吃各种callback了。<br/>
b、在自己的类的回调上，做一些hack的事情。<br/>
4、最简单的sample&hellip;&ndash;_&ndash;</p>

<figure class='code'><figcaption><span>DeriveNSURLProtocol:NSURLProtocol </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canInitWithRequest:</span><span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nv">theRequest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">//自己选择要截获怎样的request，如果要截获就返回YES</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">([</span><span class="n">theRequest</span><span class="p">.</span><span class="n">URL</span><span class="p">.</span><span class="n">scheme</span> <span class="k">case</span><span class="n">InsensitiveCompare</span>:<span class="s">@&quot;testapp&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">NSOrderedSame</span><span class="p">)</span>
</span><span class='line'>     <span class="p">{</span>
</span><span class='line'>       <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nf">canonicalRequestForRequest:</span><span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nv">theRequest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 正规化自己的request，因为request会用来找对应的cache，默认需要实现该方法，通常不需要修改。</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">theRequest</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startLoading</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//这里就开始加载了，模拟NSURLConnection的callback流程，</span>
</span><span class='line'>  <span class="c1">//依次call client的方法来模拟Connection的callback次序</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">request</span><span class="p">.</span><span class="n">URL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSURLResponse</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithURL</span><span class="o">:</span><span class="p">[</span><span class="n">request</span> <span class="n">URL</span><span class="p">]</span>
</span><span class='line'>                                                        <span class="n">MIMEType</span><span class="o">:</span><span class="s">@&quot;image/png&quot;</span>
</span><span class='line'>                                           <span class="n">expectedContentLength</span><span class="o">:-</span><span class="mi">1</span>
</span><span class='line'>                                                <span class="n">textEncodingName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">imagePath</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="n">pathForResource</span><span class="o">:</span><span class="s">@&quot;myImage&quot;</span>
</span><span class='line'>                                                           <span class="n">ofType</span><span class="o">:</span><span class="s">@&quot;png&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="n">dataWithContentsOfFile</span><span class="o">:</span><span class="n">imagePath</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocol</span><span class="o">:</span><span class="n">self</span> <span class="n">didReceiveResponse</span><span class="o">:</span><span class="n">response</span> <span class="n">cacheStoragePolicy</span><span class="o">:</span><span class="n">NSURLCacheStorageNotAllowed</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocol</span><span class="o">:</span><span class="n">self</span> <span class="n">didLoadData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocolDidFinishLoading</span><span class="o">:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">response</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stopLoading</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//加载结束</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;load over!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、更多详细介绍可以参看matt的<a href="http://nshipster.com/nsurlprotocol/">http://nshipster.com/nsurlprotocol/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/10/ioszhong-de-urlcacheji-zhi/">谈谈iOS中的HTTP缓存策略</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-10T09:03:05+08:00" pubdate data-updated="true">2014-08-10 09:03</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS中的HTTP URL Cache机制是看上较为简单，但是暗含一些机制的东西。这里将它细化下来。让自己也加深下相应的记忆。</p>

<p>首先，说下概念，HTTP URLCache是HTTP协议中的一部分，用于缓存Response，以达到减轻服务器负担的目的。在iOS中的URL Loading System中，提供了名字叫NSURLCache的类来设置URL缓存的配置信息。</p>

<p>在iOS中的URL缓存容器是共享的，因而我们可以自己继承NSURLCache来配置自己的cache，自定义化它的内存大小，磁盘大小甚至过期时间等等，最后设置为share cache即可。</p>

<p>HTTP缓存在iOS中需要，配合着NSURLRequest的缓存策略来实现的。比如，如果指定了一个Request的缓存策略，那么对应Request就会按既定策略进行处理。策略常用如下：</p>

<ul>
<li><strong>NSURLRequestUseProtocolCachePolicy</strong>。一个Request的默认缓存策略。他是最为隐晦的，我们最后说。</li>
<li><strong>NSURLRequestReturnCacheDataElseLoad</strong>。如果在之前的网络请求中，我们获取了Cache的Response，那么本次请求同样的接口，就直接从Cache中去抓。反之，从服务器上去获取，并在本地cache起来。(这里的问题是，如果cache存在，就一直拉不到服务器数据，所以用这个机制，有它的弊端，当然也要看具体的需求情况。可以通过自定义自类化NSURLCache来自定义cache time，但也仅仅适用于Data改变不大的项目中。)</li>
<li><strong>NSURLRequestReturnCacheDataDontLoad</strong>。只从缓存中获取cached response而不从服务器获取。实属离线版本。</li>
</ul>


<p>好，这里展开说一下相对最为复杂的ProtocolCachePolicy机制：<br/>
1、如果一个Request的NSCachedURLResponse不存在，就去请求网络。<br/>
2、如果一个Request的NSCachedURLResponse存在，就去检查response去决定是否需要刷新。检查Response header的Cache-Control字段是否含有must-revalidated字段(HTTP1.1所带)。<br/>
3、如果包含must-revalidated字段，就通过HEAD方法请求服务器，判断Response头是否有更新，如果有，则去拉数据下来。如果没有，则使用Cache资源。<br/>
4、如果不包含must-revalidated字段，就看看Cache-Control是否包含其他字段，比如max-age等等看看是否过期，如果过期，继续用HEAD去检查Response头，是否为最新数据，如果有则去请求服务器，反之取cache。如果没有过期，则直接取cache。</p>

<ul>
<li>注意：由于HEAD是URL Loading System自身机制，由于没有抓包，所以没去验证。HEAD方法默认使用可以参见水果文档中的Cache Use Semantics for the HTTP Protocol。</li>
</ul>


<p>然后说下通用HTTP的缓存策略：</p>

<p>  HTTP缓存策略中，我们从服务器获取Response后，可以找到(如果有)Response中包含Etag或则Last-Modified字段。当我们做第二次重复请求的时候，可以从CachedURLResponse取出来，把相应字段拼接在HTTPRequestHeader中（例如，IMS，If-Modified-Since配合Last_Modified），然后发送请求，服务端收到后，如果客户端的资源是最新的，那么就会返回304为Response，而不返回任何内容。反之，如果客户端资源落后了，则直接返回200，并返回Data给客户端。</p>

<p>最后谈谈修改NSCachedURLResponse：<br/>
在方法-(NSCachedURLResponse<em>)connection:(NSURLConnection</em>)connectionwillCacheResponse:(NSCachedURLResponse*)cachedResponse中，我们可以对即将缓存的Response进行修改，以达到自己的需求。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/wo-de-c-plus-plus-dui-xiang-mo-xing-du-shu-bi-ji-di-wu-zhang-datayu-yi-xue/">我的C++对象模型读书笔记&#8211; 第五章 Data语义学</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T09:27:24+08:00" pubdate data-updated="true">2014-08-02 09:27</time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>合理设计之一：将共享的成员放置到base class中。</p></li>
<li><p>合理设计之二：对于class的成员，应该在构造函数中或者其他的成员函数中初始化。如果让子类class去初始化base class的成员，将会破坏封装性。</p></li>
</ul>


<p>纯虚析构函数设计者一定要定义它，因为子类调用析构函数的时候，会默认静态地调用积累的虚析构函数，因此中间层如果没有定义，则会出现连接失败。因此一个较好的方案是，不要把析构函数写成纯虚。</p>

<p>如果成员member function声明成虚函数，但是函数体是一个inline形式的（如果简单地return一个member data），那么每次被调用，而根本不会被子类复写的。这样的函数调用会消耗很大的性能。因此，不要把所有函数都写成虚函数，而去等编译器优化的时候去除虚函数声明。</p>

<p>虚函数是否需要const？如果不使用const，则无法获取一个const引用或者指针，如果使用const，如果derive的对象要修改某一个datamember。因此无法协调。所以只有不使用const为好。</p>

<h4>5.1无继承体系下的对象构造（关于编译器对代码“膨胀”的实现）</h4>

<p>当类是一个Plain Ol’ Data的形式，只包含built-in数据的struct或者class的时候。那么当存在对象定义、复制、删除或者return的时候，理论上会出现trivial的构造函数、析构、赋值和拷贝构造函数。但是实际上，编译器要么是没有默认合成，要么是合成了却没有调用。</p>

<p>关于构造函数的“膨胀”：如类Point定义一个变量local(1.0,1.0,1.0)。那么对于编译器，会对默认构造函数进行内联膨胀，膨胀成 Point local; local.<em>x = 1.0; local.</em>y = 1.0; local._z = 1.0;。而对应Point *pheap = new Point;而言，会被编译器修改为如下代码：</p>

<pre><code> Point *pheap = new Point;   
 if(pheap) heap-&gt;Point::Point();
</code></pre>

<p>之后，再继续*pheap进行内联的膨胀。</p>

<p>加上virtual function之后，也会引起编译器对构造器，析构器的膨胀。加上virtual function之后，vptr的初始化就会执行，初始化于构造器中，置于所有user code之前。</p>

<p>因此，一个构造器名，如 Point::Point();会被膨胀为：</p>

<pre><code>Point::Point(Point *this)
</code></pre>

<p>而函数体最前面，会被编译器添加：</p>

<pre><code>this-&gt;_vptr = _vtbl_adrr;  //_vtbl_adrr指虚表首地址。
</code></pre>

<p>相应的，对于赋值构造、拷贝构造，编译器都会添加this,并用this去指向vptr，使得vptr被初始化，并指向当前的“合适的”虚表首地址。</p>

<p>既然标准保证在member initialization list对应的代码执行前，该对象的vptr已经被正确的设置好，那么在member initialization list中调用virtual member function，从vptr的角度来看是安全的；但如果考虑到可能存在的member之间的依赖关系，这种风格显然是不安全、不推荐使用的。</p>

<p>一般而言，如果程序中频繁的在函数中返回一个local class object，那么在设计class时，提供一个copy constructor就比较合理，它的存在会触发NRV优化。</p>

<h4>5.2继承体系下的对象构造（编译器对构造函数的扩充内容和方式）</h4>

<p>编译器扩充构造函数的主要方面可能如下：</p>

<p>1、记录在initialization list 中的data members 初始化裁做会被放进 constructor的函数本身，并以members 的声明顺序为顺序。</p>

<p>2、如果有一个member 没出现在member initialization list 之中，但是他又一个default constructor ，那么该default constructor 必须被调用</p>

<p>3、在这之前呢，如果class object 具有virtual table pointers，那么它们必须被设定处置，以指向适当的virtual table。</p>

<p>4、在那之前，所有的上一层的base class constructors必须被调用，以base class 的声明顺序为顺序。</p>

<p> a) 如果base class 被列于member initialization list 之中， 那么任何明确制定的参数都被传递过去。</p>

<p> b) 如果base class 没有被列于member initialization list 之中，而它具有default constructor,那么会调用default constructor。</p>

<p> c) 如果base class是多重继承下的第二或后继的base class,那么this 指针必须有所调整。</p>

<p>5、 在那之前，所有的virtual base class constructors 必须被调用，从做到又，从最深到最浅。</p>

<p> a) 如果 class 被列于member initialization list 之中， 那么任何明确制定的参数都被传递过去， 如果 class 没有被列于member initialization list 之中，而它具有default constructor,那么会调用default construcotr</p>

<p> b) class 中的每一个virtual base class subject 的便宜量必须在执行期间可被存取</p>

<p> c) 如果class object是最底层的class, 其constructors可能被调用，某些用以支持这个行为的机制必须被放进来！</p>

<p>具体的例子说明，见书207页-210页。</p>

<ul>
<li>关于虚拟继承，编译器需要对构造器处理的：</li>
</ul>


<p>当加入虚继承的时候，每个子类所拥有的是一个bptr，但是在子类的构造中，不可以每个子类都去调用 this->bptr->base::base()，因为虚基类只能被构造一次，因此，只有到最底层的子类，再进行对虚基类的构造器的调用。因此，在处理虚拟继承类族中的构造函数时，都会在构造函数中加入bool参数：</p>

<p>如把derive::derive()改造为 derive::derive(derive *this,bool most_derive)。若bool值为真，则说明已经到了继承体系的最底层，则会调用虚拟基类的构造函数。否则不调用虚基类的构造函数。（这里的处理，编译器会在构造函数中自行加入。）</p>

<p>这里也引发了一个问题：当一个子类对象完整的被定义出来的时候，我们会调用虚拟类的构造函数，当一个子类对象没有完整定义出来的时候，此构造函数则不会调用。因此可以生产出更有效率的编译器，它可以自行“拆解”构造器，使其更有效率，使一个“完整对象”的构造器能调用虚基类，并使用vptr。而使得“不完整对象”的构造器，无法调用虚基类和设定vptr。</p>

<p>vptr初始化语义学(The Semantics of the vptr Initialization)</p>

<p>vptr初始化是在执行期完成的，一般会发生4件事：</p>

<p>1、        derived类无条件调用base类的constructor</p>

<p>2、        调用完毕base的 constructor之后，初始化vptr。</p>

<p>3、        构造函数的成员初值列如果存在，那么将会被扩展，并且置于vptr构建之后。</p>

<p>4、        执行用户代码。</p>

<h4>5.3 对象复制语意学</h4>

<p>一个class的默认assignment operator，在如下情况下不具备bitwise copy语意：</p>

<p>class含有一个member object，且其具有assignment operator。</p>

<p>class的base class 具有 assignment operator。</p>

<p>class包含virtual function。</p>

<p>class有virtual base class。</p>

<p>概括的说，non-trivial的assignment operator不具备bitwise copy semantics。只有non-trivial的assignment operator 才会被编译器合成出来。</p>

<p>需要注意的时，并不存在与member initialization list 相对应的copy assignment list。</p>

<p>assignment operator 在 virtual inheritance 下表现不佳。</p>

<p>任何解决方案如果是以程序操作为基础，导致较高的复杂度和较大的错误倾向，一般公认，这表明语言在该方面存在弱点。</p>

<h4>5.5解构语义学</h4>

<p>如果class内带了object，且此object带有析构函数，那么class的就会自动合成一个析构函数，否则视为不需要（即便class包含虚函数）。</p>

<p>顺带需要说的是，析构函数的执行顺序和构造函数相反，此刻包括了vptr的初始化、膨胀等操作的反操作。</p>

<p>部分段落摘录自网上，稍加修改，出处不明。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/wo-de-c-plus-plus-dui-xiang-mo-xing-du-shu-bi-ji-si-zhang-the-semantics-of-function/">我的C++对象模型读书笔记&#8211;第四章 the Semantics of Function</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T09:25:15+08:00" pubdate data-updated="true">2014-08-02 09:25</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>4.1 Member的各种调用方式</h4>

<p>Nonstatic Member Functions：</p>

<p>速度和一般的Nonmember function 有相同的效率。 编译器会对nonstatic member function进行改造。加入this参数，改变函数内部的对member data 的使用方法(使用this指针来存取！)，改变函数的名字&mdash;相当于nonmember function。这里面有一个函数名字的处理问题(name mangled处理)。</p>

<p>Virtual Member Funciton：</p>

<p>首先虚函数的调用方式若是指针调用，则是通过指针，找到vptr，打出偏移找到函数地址进行调用。其次，vptr的名字也是会被“name mangled”的，因为存在较为复杂的派生体系。</p>

<p>在一个虚函数中调用另外一个虚函数，只需要写成类的函数(class::funcname())即可。因为在母函数中，执行期间已经决议出this指针指向的对象，因此上述做法可以压抑编译器的重复做法(使用vptr打偏移来做)。</p>

<p>通过一个object（对象）调用虚拟函数，这时如果需要通过vptr中转一次，就会显得较为多余，编译器在决议的时候，会直接决议成nonstatic member function。</p>

<p>Static Member Funciton：它的主要特性就是没有this指针，所以它不能够直接存取其class的nonstatic data members；也不能够被声明为virtual，const， volatile；它因此也就不需要经由某个class object 才能够被调用。他的调用速度和nonmember funciton差不多。如果取static member function的地址，那么将会是直接“Nonmember函数指针”，而不是“指向class member funciton的指针”。</p>

<h4>4.2 Virtual Member Function</h4>

<p>多重继承下的Virtual Funciton :</p>

<p>当使用base  class pointer 调用virtual function的时候，可能出现两种情况。因为该base class pointer可能指向的位置处于derived class object的开始处，也可能有一个偏移量。一般规则时，经由指向“第二或后继之base class”的志真来调用derived class virtual funciton ,改掉用操作所连带的“必要的this指针调整”操作，必须在执行期完成。</p>

<p>那么怎么处理呢？ 可能本来不需要调整的也变得要调整了！ 真是讨厌！  嘿嘿！  thunk技术被引用到了编译器中！  怎么解决呢？</p>

<p>Sun编译器的方法是提供所谓的“split functions”技术；以相同的算法产生两个函数，其中第二个在返回之前，为指针加上必要的offset，于是不论通过base1或者derived指针调用函数，都不要调整返回值；而如果通过base2指针调用，则是另外一个函数 。</p>

<p>IBM的方法呢？&#8221;把thunk搂抱在真正被调用的virtual function中。函数移开实现（1）调整this指针，然后才（2）执行程序员写的函数码；至于不需要调整的函数调用操作，就直接进入（2）部分&#8221;！</p>

<p>MS的方法以所谓的&#8217;address points&#8217;来取代thunk策略，即将用来改写别人的函数（也就是overriding function)期待获得的是&#8217;引入virtual之class&#8217;的地址。这就是&#8217;address point&#8217;</p>

<h4>4.4  指向Member Function的指针</h4>

<p>指向 nonstatic member function 指针 :取一个nonstatic member function 的地址，如果该函数是nonvirtual ,则得到的结果是他在内存中的真正的地址。然而这个值也是不完全的，需要帮盯在某个class object的地址上，才能够通过它调用该函数。所有的nonstatic member functions 都需要对象的地址（以this参数指出）。</p>

<p>指向 static member functions 指针 ：而static member functions的指针则是函数指针，而不是指向member function 的指针。</p>

<p>指向 virtual member functions 指针：对一个virtual member funciton 取地址，所能够获得的只是一个索引值。编译器在评估求值的时候，会(*ptr->vptr[(int)pmf])(ptr) !</p>

<p>后三部分摘录自互联网，出处不明。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/cpp/'>cpp (5)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (8)</a></li>

  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/10/07/control-memory-in-uiwebview/">谈谈在UIWebView中的内存控制</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/09/15/use-reactivecocoa/">使用ReactiveCocoa</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/">谈谈iOS中的多屏幕显示</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan/">谈谈iOS中的VCTransition发展</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/25/iosshou-shi-he-uishi-jian-chuan-di-de-chong-chong-xi-jie/">iOS手势和UI事件传递的种种细节</a>
      </li>
    
  </ul>
</section>




<section>
<h1>最新评论</h1>
<div id="uyan_newcmt_unit"></div>
        <script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=1970716"></script>
</section>
  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - chesterlee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a href="http://www.gehaxelt.in">Gehaxelt</a></span>
  <span class="credit">and <a href="http://www.it-solutions-neef.de">IT Solutions Neef</a></span>
</p>

</footer>
  











</body>
</html>

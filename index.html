
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Chesterlee's Zen</title>
  <meta name="author" content="chesterlee">

  
  <meta name="description" content="还没细化，概念，暂时请看https://github.com/chesterlee/UseRAC 中的代码。
博客后续更新。
">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://chesterlee.github.io/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Chesterlee's Zen" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Chesterlee's Zen</a></h1>
  
    <h2>Time's limited, so don't waste it living someone else's life</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://yahoo.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:chesterlee.github.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
  <li><a href="/about">About</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/15/use-reactivecocoa/">Use ReactiveCocoa</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-09-15T22:21:07+08:00" pubdate data-updated="true">2014-09-15 22:21</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>还没细化，概念，暂时请看<a href="https://github.com/chesterlee/UseRAC">https://github.com/chesterlee/UseRAC</a> 中的代码。
博客后续更新。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/">谈谈iOS中的多屏幕显示</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-28T21:15:49+08:00" pubdate data-updated="true">2014-08-28 21:15</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>最近接到需要进行ipad通过Apple TV进行多屏显示的需求，所以研究了下，可以在自己App中对外部荧幕进行Mirror和Different Content的切换。如果你没玩过，实在是有些可惜，不妨往下看看：</p>

<h4>初步的概念</h4>

<p>iOS App中UIWindow通常包含了App的view，连通了当前的硬件设备。而和Window联系到一起的Screen代表了特定使用的显示内容。如果你的app允许用户使用外接显示器，我们就需要创建一个UIWIndow对象来管理对外界显示器的展示。</p>

<h4>要显示内容到外部屏幕？请添加UIWindow</h4>

<p>如果你要支持外屏显示，你需要建立另外一个不同的window对象，从而让这个UIWindow对象展示的内容投射放到外部设备上。默认你可以在两个window上展示相同的内容，因为他们默认是mirroring的。当然，你可以把这个mirroring关闭了，赋值为nil或初始化一个UIWIndow到上面去。</p>

<h4>Window和Screen的概念</h4>

<p>先说说UIWindow，它组合了所有需要显示的ViewTree，并负责对subview的展示，组织他们的继承体系，以及对它们的事件传递。通常每一个App都有一个window对象来展示app自己的UI（在iOS设备上）。如果有外部显示器链接到设备上，那么app就可以使用第二个window来进行大荧幕数据的展示。<br/>
再说说UIScreen对象，对于UIWindow而言，每一个UIWindow中有一个UIScreen对象。UIScreen对象抽象地描述了一个具体显示设备的信息：bounds、mode、brightness等。你也可以监听各种消息，比如连接上显示器了，断开显示器了，显示器亮度调整了等的消息。</p>

<h4>Window和Screen的其他用途</h4>

<p>1、通过UIWindow来调整Window的亮度。还有wantsSoftwareDimming等等。
2、通过UIScreen displayLinkWithTarget:selector: 接口来在runloop进行CoreAnimation每一帧的绘制，或使用OpenGL es直接绘制。</p>

<h4>StoryBoard做了点事情</h4>

<p>使用Storyboard，建立默认的VC。它就帮你做了下面几件事情：</p>

<ul>
<li>Instantiates a window. （初始化Window）</li>
<li>Loads the main storyboard and instantiates its initial view controller. (初始化Storyboard中的initial VC)</li>
<li>Assigns the new view controller to the window’s rootViewController property and then makes the window visible.(把initial VC作为UIWindow中的RootVC，然后让Window可见)</li>
</ul>


<h4>外接显示器的实际做法</h4>

<p>默认的iOS行为：Mirror。如果默认什么都不处理，那么对于一个App而言，它的内容是直接镜像到荧幕上的。除非你要显示和iOS设备荧幕不一样的内容，你可以这样做：</p>

<ul>
<li>程序一启动，就要检查外部显示器的存在。并且注册Screen的连接和断开连接的Notification。</li>
<li>当外部显示器可用了，无论是程序启动检测，还是收到Screen连接的Notification，你都要创建并且配置一个UIWindow给这个外部设备。</li>
<li>连接这个UIWindow和这个合适的UIScreen对象，展示第二个UIWindow，并更新。</li>
</ul>


<p>BTW：如果要开启镜像，请把多出来的UIWindow给干掉就好了。</p>

<h4>代码时间</h4>

<p>好，接下来是代码时间，上面3步的代码如下：<br/>
1、当外部设备Ready的时候，创建一个UIWindow匹配外部抽象的UIScreen对象。</p>

<pre><code>- (void)checkForExistingScreenAndInitializeIfPresent
{
   if ([[UIScreen screens] count] &gt; 1)
  {
     UIScreen *secondScreen = [[UIScreen screens] objectAtIndex:1];
     CGRect screenBounds = secondScreen.bounds;
     self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
     self.secondWindow.screen = secondScreen;
     self.secondWindow.hidden = NO;
  } 
}
</code></pre>

<p>注意：UIWindow最好先和UIScreen连接起来，然后再显示UIWindow的内容，最好不要先显示UIWindow的内容，再链接UIScreen。因为非常耗资源。</p>

<p>2、注册Screen的连接和断开事件</p>

<pre><code> - (void)setUpScreenConnectionNotificationHandlers
{
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    [center addObserver:self selector:@selector(handleScreenDidConnectNotification:) name:UIScreenDidConnectNotification object:nil];
    [center addObserver:self selector:@selector(handleScreenDidDisconnectNotification:)
}
</code></pre>

<p>3、处理断开和连接的事件</p>

<pre><code>- (void)handleScreenDidConnectNotification:(NSNotification*)aNotification
{
   UIScreen *newScreen = [aNotification object];
   CGRect screenBounds = newScreen.bounds;
   if (!self.secondWindow)
   {
    self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
    self.secondWindow.screen = newScreen;
   }
}

- (void)handleScreenDidDisconnectNotification:(NSNotification*)aNotification
{
  if (self.secondWindow)
  {
    // Hide and then delete the window.
    self.secondWindow.hidden = YES;
    self.secondWindow = nil;
  }
}
</code></pre>

<p> 以上代码也可以在水果文档的多屏编码指南中找到。其实这只是一个开始，表明自己Create的UIWindow可以以抽象的方式来在外部显示器上展示，至于不断添加业务逻辑，肯定需要更好的代码封装。最后说一句，水果文档建议在AppDelegate中进行Screen的监听，其实可以按需求来进行工作。大概就这样啦。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan/">谈谈iOS中的VCTransition发展</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-26T21:19:13+08:00" pubdate data-updated="true">2014-08-26 21:19</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2>前言</h2>

<p>iOS的VCTransition一直是在跟着iOS不断变化着的，最大的感觉就是不断地解耦，动画之间VC的关联变得薄弱，或者都抽象到一个统一的位置，进行处理。下面都说下：</p>

<h4>Navigation、TabBar等切换</h4>

<p>  这个是最早(传统的)的VC风格了。比如使用如下代码：</p>

<pre><code>  -(IBAction)PushA:(id)sender 
  {  
     UIStoryboard *story = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
     AViewController *aVC = [story instantiateViewControllerWithIdentifier:@"AVCID"];  
     [self.navigationController pushViewController:aVC animated:YES]; 
  }
</code></pre>

<p>  这个方法是使用Navigation来管理VCs的一个Transition方式。比较简单，直接。但是耦合性比较大，在VC中必须知道自己要跳转到对应到VC，而且动画要写到对应的VC中，如果动画复杂，会很容易造成VC臃肿起来。</p>

<h4>VC容器的Transition</h4>

<p>由于iOS5.0后续版本新增了自定义的VC容器，那么从在容器中进行child vc之间到转场，会有专门的方法。比如如下代码:</p>

<pre><code>  [self transitionFromViewController:self.goodsCollectionVC
                  toViewController:self.mainPageVC
                          duration:SWITCH_VCS_TIME
                          options:UIViewAnimationOptionTransitionCrossDissolve animations:^{
                  // do animation things
} completion:^(BOOL finished) {
    // do animation completion things
}];
</code></pre>

<p>这个方法在容器中切换subVC比较方便，但是只实现了简单的Transition动画，并且依然是有耦合的。因为Container做动画的切换VC的时候，如果动画非常复杂，依然会有动画无法复用的状况。</p>

<h4>StoryBoard和Segue</h4>

<p>  这个是iOS5时提供的转场方式：通过在Storyboard中或代码中定义Push、Modal或 Custom segue，定义一个SegueID，然后需要做Transition的时候，去Perform一个Segue就可以了，代码如下：</p>

<pre><code>  [self performSegueWithIdentifier:@"PushSegueID" sender:self];  
</code></pre>

<p>在执行动画之前，自己的VC就要做些preparation可以在如下代码中调用</p>

<pre><code>  -(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender NS_AVAILABLE_IOS(5_0){} 
</code></pre>

<p>  特别需要说一下，如果动画处理复杂的，通过Custom Segue，就可以把动画挪到自定义segue中，降低sourceVC的代码量，动画也可以解耦甚至抽象。主要步骤就有两个：<br/>
  &ndash; 在Storybaord或代码中实例化自定义的segue。
  &ndash; 自定义Segue类复写perform方法。<br/>
  关键代码如下：</p>

<pre><code>   -(void)perform
   {
      id sourceVC = self.sourceViewController;
      id destVC = self.destinationViewController;
      //Do animation  
    }
</code></pre>

<p> segue 最关键的两个property，一个是sourceViewController，一个是destinationViewController，就实现一个动画而言，这两个变量就够了。</p>

<h4>iOS7的Transition</h4>

<p>iOS7提供了新的transition方式。默认提供了Present和Push的抽象动画，新增了percent的手势交互动画。例如，如果要自定义navigation push的动画就可以实现一个支持UIViewControllerAnimatedTransitioning的对象。在这个transition对象中，来设计自己的动画。和segue类似，代码可见：</p>

<pre><code>   -(void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
   {
        UIViewController *destController =  [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];  
        UIViewController *fromController =  [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
        UIView *containerView = [transitionContext containerView];  
        [containerView addSubview:destController.view];
   }
</code></pre>

<p>和Segue相同的是，都可以通过对象来获取Source和DestinationVC。不同的是，iOS7新提供的Transition提供了ContainerView，来做动画交互的容器。<br/>
对于外部而言，在代理中制定对应的Custom Transition对象即可使用他们了，可定制化更高：<br/>
比如在VC Controller中实例化对应的代理方法：</p>

<pre><code>   -(id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                               animationControllerForOperation:(UINavigationControllerOperation)operation
                                            fromViewController:(UIViewController *)fromVC
                                              toViewController:(UIViewController *)toVC
                                         {
                                            if (someCondition) 
                                            {
                                              _naviTransitioning.operation = operation;
                                              return  _naviTransitioning;
                                            }
                                            return nil;
                                          }
</code></pre>

<p>至于iOS7的UIPercentDrivenInteractiveTransition，这里不展开讲了，具体可以搜搜相关文档。<br/>
经过Transition的不断强化，iOS7新增的Transition，大大增强了动画的复用性，降低了耦合度，增加了交互性，给编码人员提供更多福利。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/25/iosshou-shi-he-uishi-jian-chuan-di-de-chong-chong-xi-jie/">iOS手势和UI事件传递的种种细节</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-25T20:03:53+08:00" pubdate data-updated="true">2014-08-25 20:03</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>做iOS交互，最为重要的就是UI的事件传递需要很清楚。当然也要包括各种&#8221;小&#8221;细节。
这里首先说说大的过程，也是UI事件传递的基本过程：当APP收到用户点击之后，就会做两个过程：</p>

<ul>
<li>1、遍历树，找哪个UIView是被Point击中。</li>
<li>2、回溯tree node，形成响应者链。剩下的就是UIEvent的传递了。</li>
</ul>


<p>现在让我们谈谈几个问题，一个View添加了Gesture了，那么在它之上的touches的回调会收到调用吗？一个view的superview的VC添加了手势，那么在该view中的touches会收到调用吗？如何正确地传递给superview相应touches调用？UITouch里面有什么东西？如果这些有些不太清楚，那么请往下看。</p>

<h4>几个不得不提的概念:</h4>

<ul>
<li>Touches began/Moved/Cancelled/touchesEnded是UIResponder的接口，用于接收触摸的各种事件。<strong>过程简述为UserTouch&mdash;>UIApplication&mdash;>UIWindow&mdash;>UIView</strong>。</li>
<li><strong>UITouch代表一个手指，从开始接触屏幕到离开屏幕的触碰描述数据</strong>。展开来说，UITouch包含了上一次手指的位置信息，当前的UITouch的状态TouchPhase，当前的时间戳以及UITouch要送往的那些以定义的手势。具体作用和关联，后面讲。</li>
<li>当发生了触摸时，UIEvent就会包含UITouch的数组，被App送到对应的Responder上（如果这个Responder书写了touchesBegan等UITouch的回调的话）。</li>
<li>UITouch的状态机有TouchPhaseBegan、Moved、Ended几个。当然，分别对应那几个回调。这里请注意，<strong>UITouch的状态机和手势的状态机如UIGestureRecognizerStateBegan，是完全不同的，千万不要混淆</strong>.</li>
<li><strong>Gesture的状态</strong>：单独Gesture(如Tap)是有识别状态的，一个叫Possible，一个叫Recognized，一个叫Failed。而连续Gesture(如Pinch)相比之下多了began、changed等状态。</li>
</ul>


<hr />

<h4>UITouch的发送机制：</h4>

<p>一句话：手势先于UIView获取Touch的响应权。详细说来：当对屏幕进行点击的时候，如前面所说，UITouch的对象会从UIApplication被依次传递，这里如果View或者其superview添加了Gesture。默认状况下：UITouch就会被送到这个Gesture上去识别，如果Gesture无法识别则会送UITouch对象点到的那个UIView上去做响应。</p>

<p>回答前两个问题：这个事件先发送到一个Gesture上，并不意味着会结束touches等的调用，这个调用只是delay了。所以，第一个问题，它的touches began会收到回调，它的superview及其VC都会收到touches began的回调。而且began，moved有可能还先于手势收到回调，原因是就是Gesture对UI事件调用的影响原则：</p>

<ul>
<li>如果在某个时刻，如果Gesture根据UITouch的变化识别出了自己的手势，把Possble状态跳到了Recognized状态。那么App将不会给对应的View或VC发送后续的UIEvent。转而，UITouch的事件将会没有走完，且会收到touches:Cancelled事件而不会收到touches:Ended事件。</li>
<li>如果整个过程中，Gesture都没有识别出自己的手势，那么它会设置自己的状态未Failed。那么这些UITouch对象会被转发给对应的UIView或VC。</li>
</ul>


<p>最后说说UItouches中包含了一个gestureRecognizers数组作用是什么呢，注意这个小过程：</p>

<ul>
<li>UITouch是通过touchesBegan、touchesMoved、touchesEnded等方法被送到对应的Gesture上的。UITouch其实也就是记录了被注册的Gesture对象的指针，这里就被传递到手势上了。</li>
<li>因此，在默认状况下，如果一个view注册了touchesBegan、它或它的superview注册了Gesture，touchesbegan会先于Gesgure收到UITouch。</li>
</ul>


<hr />

<h4>所以，在这里总结下，默认状况下手势是通过touchesBegan等事件传递的方式获取UITouch，并根据UITouch的变化进行了手势自身的判断，如果手势判断成功，手势自身的状态就会从Possible变为Recognized，从而阻止了touchesEnded的调用。但是在这个过程中，默认touchesBegan是先被目标view调用的。</h4>

<p>最后说说delaysTouchesBegan 和 delaysTouchesEnded</p>

<ul>
<li><strong>概念</strong>。这两个属性是手势的，默认delaysTouchesBegan为NO，delaysTouchesEnded为Yes。表示的涵义是：不延迟touchesBegan调用，目标View可以接到这些事件，而Delay TouchesEnded的调用。让手势获取最终的决定权。PS:他们的影响类似ScrollView中的delaysContentTouches变量，是否把延迟把UITouch传递给ScrollView中的subView。</li>
<li><strong>配置</strong>。你可以把delaysTouchesBegan开启，阻止touchesBegan调用，直接收到手势。但是这样会有时让用户感到UI失去响应。
delaysTouchesEnded也可以被设置为NO，如果这样的话当delaysTouchesBegan为NO的情况，UITouch就会被传递到目标UIView上，相当于:UIView自己接事件，而且手势也去接事件。</li>
</ul>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/24/ios7zhong-ui-trick/">edgesForExtendedLayout、automaticallyAdjustsScrollViewInsets和extendedLayoutIncludesOpaqueBars</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-24T23:58:15+08:00" pubdate data-updated="true">2014-08-24 23:58</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>这几个属性值得写清楚，因为他们有组合起来使用的状况，有时候情况会变得较为复杂。</p>

<p>edgesForExtendedLayout：UIRectEdgeTop 延伸是会影响childviewcontroller的向上延伸的特点。（正确地说，是UINavigationController 作用所有的sub ViewController 中的向上延伸的特性。）如果edgesForExtendedLayout包含了UIRectEdgeTop，那么childVC的view会占据整个屏幕，反之，它会置于Navigationbar的offsetY下面。</p>

<p>automaticallyAdjustsScrollViewInsets：它的涵义是：如果UINavigationController或UIToolbarViewController的子View是Scrollview及其子类，在edgesForExtendedLayout含有top的状况下，会修改ScrollView的ContentInsect，来满足Scrollview的内容向上滑动时，statubar和navigation bar浮在其内容上。当然，如果edgesForExtendedLayout如果不含有top，那么就关闭了浮在navigation bar和statubar的特性，automaticallyAdjustsScrollViewInsets的作用也就失去意义了- &ndash;>此时NavigationController不会因为这个值是YES来设置scrollview的contentInsects。PS：（对挂接到一个view的tableview或scrollview是无效的。注意这里如果使用了childviewcontroller就可以验证这一点了。）</p>

<p>extendedLayoutIncludesOpaqueBars，这个属性指定了当Bar使用了不透明图片时，视图是否延伸至Bar所在区域，默认值时NO。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/15/tan-tan-ioszhong-de-nsurlprotocol/">谈谈iOS中的NSURLProtocol</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-15T10:23:37+08:00" pubdate data-updated="true">2014-08-15 10:23</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>NSURLProtocol是比较&#8221;小众&#8221;，但是能量极大的一个东东。在NSHipster中matt对其有详细介绍。<br/>
它就像在少林寺里，武功最高的，就是在一旁扫落叶的僧人，默默无闻，你一旦发现他，各种绝学就来了。<br/>
&ndash;_-扯远了，我们先看看它是什么，然后看看它能干什么。</p>

<p>1、它的概念：
它是一个抽象类，我们可以通过继承它来定义新的或已存在的URL加载行为。<br/>
2、就它的功效而言,它可以做各种hack的事情：^_^</p>

<ul>
<li>拦截获取图片的Request，然后自行加载自己的图片。</li>
<li>自己拦截特定Request，然后自己做签名，header修改。</li>
<li>过滤Response、Request中的敏感信息，当然也可以加上敏感信息-0-。</li>
<li>支持NSURLConnection的callback协议，可以对上层完全透明。</li>
</ul>


<p>3、怎么用？<br/>
只需要做两件事情： <br/>
a、子类化NSURLProtocol类，并注册。APP启动后，但做网络请求之前，就可以干这事情了。后续iOS必然是单例化你的类，然后吃各种callback了。<br/>
b、在自己的类的回调上，做一些hack的事情。<br/>
4、最简单的sample&hellip;&ndash;_&ndash;</p>

<figure class='code'><figcaption><span>DeriveNSURLProtocol:NSURLProtocol </span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class='objectivec'><span class='line'><span class="k">+</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canInitWithRequest:</span><span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nv">theRequest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>   <span class="c1">//自己选择要截获怎样的request，如果要截获就返回YES</span>
</span><span class='line'>     <span class="k">if</span> <span class="p">([</span><span class="n">theRequest</span><span class="p">.</span><span class="n">URL</span><span class="p">.</span><span class="n">scheme</span> <span class="k">case</span><span class="n">InsensitiveCompare</span>:<span class="s">@&quot;testapp&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">NSOrderedSame</span><span class="p">)</span>
</span><span class='line'>     <span class="p">{</span>
</span><span class='line'>       <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>     <span class="p">}</span>
</span><span class='line'>     <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">+</span> <span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nf">canonicalRequestForRequest:</span><span class="p">(</span><span class="n">NSURLRequest</span><span class="o">*</span><span class="p">)</span><span class="nv">theRequest</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">// 正规化自己的request，因为request会用来找对应的cache，默认需要实现该方法，通常不需要修改。</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">theRequest</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">startLoading</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//这里就开始加载了，模拟NSURLConnection的callback流程，</span>
</span><span class='line'>  <span class="c1">//依次call client的方法来模拟Connection的callback次序</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">request</span><span class="p">.</span><span class="n">URL</span><span class="p">);</span>
</span><span class='line'>  <span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSURLResponse</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithURL</span><span class="o">:</span><span class="p">[</span><span class="n">request</span> <span class="n">URL</span><span class="p">]</span>
</span><span class='line'>                                                        <span class="n">MIMEType</span><span class="o">:</span><span class="s">@&quot;image/png&quot;</span>
</span><span class='line'>                                           <span class="n">expectedContentLength</span><span class="o">:-</span><span class="mi">1</span>
</span><span class='line'>                                                <span class="n">textEncodingName</span><span class="o">:</span><span class="nb">nil</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSString</span> <span class="o">*</span><span class="n">imagePath</span> <span class="o">=</span> <span class="p">[[</span><span class="n">NSBundle</span> <span class="n">mainBundle</span><span class="p">]</span> <span class="n">pathForResource</span><span class="o">:</span><span class="s">@&quot;myImage&quot;</span>
</span><span class='line'>                                                           <span class="n">ofType</span><span class="o">:</span><span class="s">@&quot;png&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="n">dataWithContentsOfFile</span><span class="o">:</span><span class="n">imagePath</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocol</span><span class="o">:</span><span class="n">self</span> <span class="n">didReceiveResponse</span><span class="o">:</span><span class="n">response</span> <span class="n">cacheStoragePolicy</span><span class="o">:</span><span class="n">NSURLCacheStorageNotAllowed</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocol</span><span class="o">:</span><span class="n">self</span> <span class="n">didLoadData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[[</span><span class="n">self</span> <span class="n">client</span><span class="p">]</span> <span class="n">URLProtocolDidFinishLoading</span><span class="o">:</span><span class="n">self</span><span class="p">];</span>
</span><span class='line'>  <span class="p">[</span><span class="n">response</span> <span class="n">release</span><span class="p">];</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">stopLoading</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="c1">//加载结束</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;load over!&quot;</span><span class="p">);</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>5、更多详细介绍可以参看matt的<a href="http://nshipster.com/nsurlprotocol/">http://nshipster.com/nsurlprotocol/</a></p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/10/ioszhong-de-urlcacheji-zhi/">谈谈iOS中的HTTP缓存策略</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-10T09:03:05+08:00" pubdate data-updated="true">2014-08-10 09:03</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>iOS中的HTTP URL Cache机制是看上较为简单，但是暗含一些机制的东西。这里将它细化下来。让自己也加深下相应的记忆。</p>

<p>首先，说下概念，HTTP URLCache是HTTP协议中的一部分，用于缓存Response，以达到减轻服务器负担的目的。在iOS中的URL Loading System中，提供了名字叫NSURLCache的类来设置URL缓存的配置信息。</p>

<p>在iOS中的URL缓存容器是共享的，因而我们可以自己继承NSURLCache来配置自己的cache，自定义化它的内存大小，磁盘大小甚至过期时间等等，最后设置为share cache即可。</p>

<p>HTTP缓存在iOS中需要，配合着NSURLRequest的缓存策略来实现的。比如，如果指定了一个Request的缓存策略，那么对应Request就会按既定策略进行处理。策略常用如下：</p>

<ul>
<li><strong>NSURLRequestUseProtocolCachePolicy</strong>。一个Request的默认缓存策略。他是最为隐晦的，我们最后说。</li>
<li><strong>NSURLRequestReturnCacheDataElseLoad</strong>。如果在之前的网络请求中，我们获取了Cache的Response，那么本次请求同样的接口，就直接从Cache中去抓。反之，从服务器上去获取，并在本地cache起来。(这里的问题是，如果cache存在，就一直拉不到服务器数据，所以用这个机制，有它的弊端，当然也要看具体的需求情况。可以通过自定义自类化NSURLCache来自定义cache time，但也仅仅适用于Data改变不大的项目中。)</li>
<li><strong>NSURLRequestReturnCacheDataDontLoad</strong>。只从缓存中获取cached response而不从服务器获取。实属离线版本。</li>
</ul>


<p>好，这里展开说一下相对最为复杂的ProtocolCachePolicy机制：<br/>
1、如果一个Request的NSCachedURLResponse不存在，就去请求网络。<br/>
2、如果一个Request的NSCachedURLResponse存在，就去检查response去决定是否需要刷新。检查Response header的Cache-Control字段是否含有must-revalidated字段(HTTP1.1所带)。<br/>
3、如果包含must-revalidated字段，就通过HEAD方法请求服务器，判断Response头是否有更新，如果有，则去拉数据下来。如果没有，则使用Cache资源。<br/>
4、如果不包含must-revalidated字段，就看看Cache-Control是否包含其他字段，比如max-age等等看看是否过期，如果过期，继续用HEAD去检查Response头，是否为最新数据，如果有则去请求服务器，反之取cache。如果没有过期，则直接取cache。</p>

<ul>
<li>注意：由于HEAD是URL Loading System自身机制，由于没有抓包，所以没去验证。HEAD方法默认使用可以参见水果文档中的Cache Use Semantics for the HTTP Protocol。</li>
</ul>


<p>然后说下通用HTTP的缓存策略：</p>

<p>  HTTP缓存策略中，我们从服务器获取Response后，可以找到(如果有)Response中包含Etag或则Last-Modified字段。当我们做第二次重复请求的时候，可以从CachedURLResponse取出来，把相应字段拼接在HTTPRequestHeader中（例如，IMS，If-Modified-Since配合Last_Modified），然后发送请求，服务端收到后，如果客户端的资源是最新的，那么就会返回304为Response，而不返回任何内容。反之，如果客户端资源落后了，则直接返回200，并返回Data给客户端。</p>

<p>最后谈谈修改NSCachedURLResponse：<br/>
在方法-(NSCachedURLResponse<em>)connection:(NSURLConnection</em>)connectionwillCacheResponse:(NSCachedURLResponse*)cachedResponse中，我们可以对即将缓存的Response进行修改，以达到自己的需求。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/wo-de-c-plus-plus-dui-xiang-mo-xing-du-shu-bi-ji-di-wu-zhang-datayu-yi-xue/">我的C++对象模型读书笔记&#8211; 第五章 Data语义学</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T09:27:24+08:00" pubdate data-updated="true">2014-08-02 09:27</time>
        
      </p>
    
  </header>


  <div class="entry-content"><ul>
<li><p>合理设计之一：将共享的成员放置到base class中。</p></li>
<li><p>合理设计之二：对于class的成员，应该在构造函数中或者其他的成员函数中初始化。如果让子类class去初始化base class的成员，将会破坏封装性。</p></li>
</ul>


<p>纯虚析构函数设计者一定要定义它，因为子类调用析构函数的时候，会默认静态地调用积累的虚析构函数，因此中间层如果没有定义，则会出现连接失败。因此一个较好的方案是，不要把析构函数写成纯虚。</p>

<p>如果成员member function声明成虚函数，但是函数体是一个inline形式的（如果简单地return一个member data），那么每次被调用，而根本不会被子类复写的。这样的函数调用会消耗很大的性能。因此，不要把所有函数都写成虚函数，而去等编译器优化的时候去除虚函数声明。</p>

<p>虚函数是否需要const？如果不使用const，则无法获取一个const引用或者指针，如果使用const，如果derive的对象要修改某一个datamember。因此无法协调。所以只有不使用const为好。</p>

<h4>5.1无继承体系下的对象构造（关于编译器对代码“膨胀”的实现）</h4>

<p>当类是一个Plain Ol’ Data的形式，只包含built-in数据的struct或者class的时候。那么当存在对象定义、复制、删除或者return的时候，理论上会出现trivial的构造函数、析构、赋值和拷贝构造函数。但是实际上，编译器要么是没有默认合成，要么是合成了却没有调用。</p>

<p>关于构造函数的“膨胀”：如类Point定义一个变量local(1.0,1.0,1.0)。那么对于编译器，会对默认构造函数进行内联膨胀，膨胀成 Point local; local.<em>x = 1.0; local.</em>y = 1.0; local._z = 1.0;。而对应Point *pheap = new Point;而言，会被编译器修改为如下代码：</p>

<pre><code> Point *pheap = new Point;   
 if(pheap) heap-&gt;Point::Point();
</code></pre>

<p>之后，再继续*pheap进行内联的膨胀。</p>

<p>加上virtual function之后，也会引起编译器对构造器，析构器的膨胀。加上virtual function之后，vptr的初始化就会执行，初始化于构造器中，置于所有user code之前。</p>

<p>因此，一个构造器名，如 Point::Point();会被膨胀为：</p>

<pre><code>Point::Point(Point *this)
</code></pre>

<p>而函数体最前面，会被编译器添加：</p>

<pre><code>this-&gt;_vptr = _vtbl_adrr;  //_vtbl_adrr指虚表首地址。
</code></pre>

<p>相应的，对于赋值构造、拷贝构造，编译器都会添加this,并用this去指向vptr，使得vptr被初始化，并指向当前的“合适的”虚表首地址。</p>

<p>既然标准保证在member initialization list对应的代码执行前，该对象的vptr已经被正确的设置好，那么在member initialization list中调用virtual member function，从vptr的角度来看是安全的；但如果考虑到可能存在的member之间的依赖关系，这种风格显然是不安全、不推荐使用的。</p>

<p>一般而言，如果程序中频繁的在函数中返回一个local class object，那么在设计class时，提供一个copy constructor就比较合理，它的存在会触发NRV优化。</p>

<h4>5.2继承体系下的对象构造（编译器对构造函数的扩充内容和方式）</h4>

<p>编译器扩充构造函数的主要方面可能如下：</p>

<p>1、记录在initialization list 中的data members 初始化裁做会被放进 constructor的函数本身，并以members 的声明顺序为顺序。</p>

<p>2、如果有一个member 没出现在member initialization list 之中，但是他又一个default constructor ，那么该default constructor 必须被调用</p>

<p>3、在这之前呢，如果class object 具有virtual table pointers，那么它们必须被设定处置，以指向适当的virtual table。</p>

<p>4、在那之前，所有的上一层的base class constructors必须被调用，以base class 的声明顺序为顺序。</p>

<p> a) 如果base class 被列于member initialization list 之中， 那么任何明确制定的参数都被传递过去。</p>

<p> b) 如果base class 没有被列于member initialization list 之中，而它具有default constructor,那么会调用default constructor。</p>

<p> c) 如果base class是多重继承下的第二或后继的base class,那么this 指针必须有所调整。</p>

<p>5、 在那之前，所有的virtual base class constructors 必须被调用，从做到又，从最深到最浅。</p>

<p> a) 如果 class 被列于member initialization list 之中， 那么任何明确制定的参数都被传递过去， 如果 class 没有被列于member initialization list 之中，而它具有default constructor,那么会调用default construcotr</p>

<p> b) class 中的每一个virtual base class subject 的便宜量必须在执行期间可被存取</p>

<p> c) 如果class object是最底层的class, 其constructors可能被调用，某些用以支持这个行为的机制必须被放进来！</p>

<p>具体的例子说明，见书207页-210页。</p>

<ul>
<li>关于虚拟继承，编译器需要对构造器处理的：</li>
</ul>


<p>当加入虚继承的时候，每个子类所拥有的是一个bptr，但是在子类的构造中，不可以每个子类都去调用 this->bptr->base::base()，因为虚基类只能被构造一次，因此，只有到最底层的子类，再进行对虚基类的构造器的调用。因此，在处理虚拟继承类族中的构造函数时，都会在构造函数中加入bool参数：</p>

<p>如把derive::derive()改造为 derive::derive(derive *this,bool most_derive)。若bool值为真，则说明已经到了继承体系的最底层，则会调用虚拟基类的构造函数。否则不调用虚基类的构造函数。（这里的处理，编译器会在构造函数中自行加入。）</p>

<p>这里也引发了一个问题：当一个子类对象完整的被定义出来的时候，我们会调用虚拟类的构造函数，当一个子类对象没有完整定义出来的时候，此构造函数则不会调用。因此可以生产出更有效率的编译器，它可以自行“拆解”构造器，使其更有效率，使一个“完整对象”的构造器能调用虚基类，并使用vptr。而使得“不完整对象”的构造器，无法调用虚基类和设定vptr。</p>

<p>vptr初始化语义学(The Semantics of the vptr Initialization)</p>

<p>vptr初始化是在执行期完成的，一般会发生4件事：</p>

<p>1、        derived类无条件调用base类的constructor</p>

<p>2、        调用完毕base的 constructor之后，初始化vptr。</p>

<p>3、        构造函数的成员初值列如果存在，那么将会被扩展，并且置于vptr构建之后。</p>

<p>4、        执行用户代码。</p>

<h4>5.3 对象复制语意学</h4>

<p>一个class的默认assignment operator，在如下情况下不具备bitwise copy语意：</p>

<p>class含有一个member object，且其具有assignment operator。</p>

<p>class的base class 具有 assignment operator。</p>

<p>class包含virtual function。</p>

<p>class有virtual base class。</p>

<p>概括的说，non-trivial的assignment operator不具备bitwise copy semantics。只有non-trivial的assignment operator 才会被编译器合成出来。</p>

<p>需要注意的时，并不存在与member initialization list 相对应的copy assignment list。</p>

<p>assignment operator 在 virtual inheritance 下表现不佳。</p>

<p>任何解决方案如果是以程序操作为基础，导致较高的复杂度和较大的错误倾向，一般公认，这表明语言在该方面存在弱点。</p>

<h4>5.5解构语义学</h4>

<p>如果class内带了object，且此object带有析构函数，那么class的就会自动合成一个析构函数，否则视为不需要（即便class包含虚函数）。</p>

<p>顺带需要说的是，析构函数的执行顺序和构造函数相反，此刻包括了vptr的初始化、膨胀等操作的反操作。</p>

<p>部分段落摘录自网上，稍加修改，出处不明。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/08/02/wo-de-c-plus-plus-dui-xiang-mo-xing-du-shu-bi-ji-si-zhang-the-semantics-of-function/">我的C++对象模型读书笔记&#8211;第四章 the Semantics of Function</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-08-02T09:25:15+08:00" pubdate data-updated="true">2014-08-02 09:25</time>
        
      </p>
    
  </header>


  <div class="entry-content"><h4>4.1 Member的各种调用方式</h4>

<p>Nonstatic Member Functions：</p>

<p>速度和一般的Nonmember function 有相同的效率。 编译器会对nonstatic member function进行改造。加入this参数，改变函数内部的对member data 的使用方法(使用this指针来存取！)，改变函数的名字&mdash;相当于nonmember function。这里面有一个函数名字的处理问题(name mangled处理)。</p>

<p>Virtual Member Funciton：</p>

<p>首先虚函数的调用方式若是指针调用，则是通过指针，找到vptr，打出偏移找到函数地址进行调用。其次，vptr的名字也是会被“name mangled”的，因为存在较为复杂的派生体系。</p>

<p>在一个虚函数中调用另外一个虚函数，只需要写成类的函数(class::funcname())即可。因为在母函数中，执行期间已经决议出this指针指向的对象，因此上述做法可以压抑编译器的重复做法(使用vptr打偏移来做)。</p>

<p>通过一个object（对象）调用虚拟函数，这时如果需要通过vptr中转一次，就会显得较为多余，编译器在决议的时候，会直接决议成nonstatic member function。</p>

<p>Static Member Funciton：它的主要特性就是没有this指针，所以它不能够直接存取其class的nonstatic data members；也不能够被声明为virtual，const， volatile；它因此也就不需要经由某个class object 才能够被调用。他的调用速度和nonmember funciton差不多。如果取static member function的地址，那么将会是直接“Nonmember函数指针”，而不是“指向class member funciton的指针”。</p>

<h4>4.2 Virtual Member Function</h4>

<p>多重继承下的Virtual Funciton :</p>

<p>当使用base  class pointer 调用virtual function的时候，可能出现两种情况。因为该base class pointer可能指向的位置处于derived class object的开始处，也可能有一个偏移量。一般规则时，经由指向“第二或后继之base class”的志真来调用derived class virtual funciton ,改掉用操作所连带的“必要的this指针调整”操作，必须在执行期完成。</p>

<p>那么怎么处理呢？ 可能本来不需要调整的也变得要调整了！ 真是讨厌！  嘿嘿！  thunk技术被引用到了编译器中！  怎么解决呢？</p>

<p>Sun编译器的方法是提供所谓的“split functions”技术；以相同的算法产生两个函数，其中第二个在返回之前，为指针加上必要的offset，于是不论通过base1或者derived指针调用函数，都不要调整返回值；而如果通过base2指针调用，则是另外一个函数 。</p>

<p>IBM的方法呢？&#8221;把thunk搂抱在真正被调用的virtual function中。函数移开实现（1）调整this指针，然后才（2）执行程序员写的函数码；至于不需要调整的函数调用操作，就直接进入（2）部分&#8221;！</p>

<p>MS的方法以所谓的&#8217;address points&#8217;来取代thunk策略，即将用来改写别人的函数（也就是overriding function)期待获得的是&#8217;引入virtual之class&#8217;的地址。这就是&#8217;address point&#8217;</p>

<h4>4.4  指向Member Function的指针</h4>

<p>指向 nonstatic member function 指针 :取一个nonstatic member function 的地址，如果该函数是nonvirtual ,则得到的结果是他在内存中的真正的地址。然而这个值也是不完全的，需要帮盯在某个class object的地址上，才能够通过它调用该函数。所有的nonstatic member functions 都需要对象的地址（以this参数指出）。</p>

<p>指向 static member functions 指针 ：而static member functions的指针则是函数指针，而不是指向member function 的指针。</p>

<p>指向 virtual member functions 指针：对一个virtual member funciton 取地址，所能够获得的只是一个索引值。编译器在评估求值的时候，会(*ptr->vptr[(int)pmf])(ptr) !</p>

<p>后三部分摘录自互联网，出处不明。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/07/26/wo-de-c-plus-plus-dui-xiang-mo-xing-du-shu-bi-ji-san-zhang-datayu-yi-xue/">我的C++对象模型读书笔记&#8211;第三章 Data语义学</a></h1>
    
    
      <p class="meta">
        








  


<time datetime="2014-07-26T22:16:51+08:00" pubdate data-updated="true">2014-07-26 22:16</time>
        
      </p>
    
  </header>


  <div class="entry-content"><p> C++ standard 不强制规定“base class subjects的排列次序”“不同存取层记得data members的排列次序” ，也不规定“virtual funcitons 和 virtual base class“的实现细节。
当一个类并没有任何声明的时候，它实做一个对象的时候，实际分配了1个字节的大小的空间。从而使得这个对象能够有独一无二的地址空间。</p>

<p>而一个对象的大小不仅仅包含了该类所声明的nonstatic data members，而且还受到了，</p>

<p>1、支持语言特性（各种virtual特性）。</p>

<p>2、边界对齐特性。</p>

<p>两个部分的影响。而形成其最终大小。</p>

<hr />

<h4>3.1 Data Member的绑定(The Binding of a Data Member)</h4>

<p> 数据成员的绑定指数据成员与函数成员的一体性，因此无需使用“防御性编码风格”。</p>

<p> 所谓防御性编码风格，在C++具体所指是：</p>

<p>1、所有的data member都放到了class声明的开始处。（原因：成员函数调用成员变量的时候，需要知道成员变量是哪一个成员变量，早期c++没有做到绑定，那么就需要类似“前置声明”一样的做法告诉编译器。）</p>

<p>2、所有的inline function，不管长度都放置到class声明之外。（原因：当类的声明结束之后，member function本身才会开始被分析，而member function对数据成员的绑定操作会在整个class声明完成之后才发生。）</p>

<p>但是以上两种基本无需实现，因为C++编译器已经能够解决。</p>

<p>反倒是函数参数列表的形式，必须使用防御性编码风格。因为它不是在类完成之后被决议的，反而是在他们第一次遇到编译器的时候，就决议了。因此，例如，若在全局范围做typedef int length;并在class中先做了function的处理声明。那么若在随后的member data声明的时候加上typedef float length;则会出现参考操作不合法的情况。</p>

<h4>3.2  Data member 的布局</h4>

<p>C++ standard要求：在同一个access section 的member只要符合“较晚出现的members在class object中有较高的内存地址”即可，各个member之间并不一定需要得到连续的排列。当前编译器都是把一个以上的access section连锁到一起存放于内存，形成连续区块。可以使用内存高低的办法，去写一个函数，判断同一个类中，哪一个access section先出现。</p>

<p>VPTR的存放位置也不一定，个个编译器自行规定。</p>

<h4>3.3 Data Member的存取</h4>

<p>static data member：只要是static member，那么存取就是一个固定的时间，因为他相当于一个global变量。如果取一个static data member的地址，就会得到一个指向其数据类型的指针，而不是一个指向其class member的指针。因为static member并不包含在一个class object 之中。既然static member放在global data segment之中，就需要对他进行命名处理，防止命名的冲突（注意，这里应该使用的name-mangling处理方法，进行1，名称计算。2名称还原。）</p>

<p>再有，存取static data member不需要用对象(object)去获取，这只是一种语法上的便宜行事而已。</p>

<p>Nonstatic data member：对一个nonstatic data member进行存取操作，编译器需要把class object的首地址加上data member在对象中的偏移量(offset)。origin._x&mdash;-等价于&mdash;>  &amp;origin+(&amp;Point3D::x-1); （-1的操作是用于判断指针是指向class的第一个member还是什么都没有指向。后面详述。）</p>

<p>因为它的偏移量会在编译期间得到，因此如果该data member属于一个base class subjects的时候情况也一样。</p>

<p>在虚继承的情况下：“经由base class subject存取class members”会增加一层新的间接性(bptr)。如果是由对象访问base class的数据成员(origin.x = 0;)，和上面的时间一样，因为它的偏移量在编译期间已经固定了，而如果是有一个指针来访问(如，pt->x = 0;)，则会很复杂，因为不知道该指针是指向什么类型的的对象。可能是base class，也可能是一个derived class，所以这个操作需啊放置到执行期能解决。</p>

<h4>3.4“继承”和 Data Member</h4>

<p>C++中，一个derived class object的空间是自己的members加上base class members。而之间的排列次序在C++  standard中并未强制指定。大部分编译器而言，都是把base class members放在前面。</p>

<p>单独“继承”时候的Data Member：</p>

<p>这里书上提到了一个值得讨论的地方：</p>

<p>关于基类和子类的Data Member在补齐上的问题，是否需要以每个base member的空间+补齐空间+derive空间来实例化一个derive object？是的。因为如果每个class的对象空间补齐部分被填入member，那么对象之间的member wise复制操作将会破坏被复制的对象member。（当然，这是编译器落实的事情J）</p>

<h5>加上多态</h5>

<p>加上多态之后，将会给类的存取时间和空间带来额外的负担：</p>

<p>1、加入了vtabl（对于类）。</p>

<p>2、加入了vptr（对于对象）。(C++ 1.0置于对象空间尾部，2.0之后置于首部。)</p>

<p>3、加强了构造器的能力。（构造器中，设置vptr指向的初值）</p>

<p>4、加强了析构器的能力。（析构器重，抹掉vptr指向的值）</p>

<h5>加上多重继承：</h5>

<p>注意，在多继承中，存在基类没有virtual function，子类存在virtual function的情况，那么自然多态就会被打破，编译器需要介入。在把子类指针赋值给基类ptr的时候，编译器也需要介入。</p>

<p>在进行指针转换的情况下，我们总需要进行基地址+offset的方法来调整(编译器是这样做的J)。通过这样的调整，能够使得基类指针类型，指向子类中基类的那个部分的首地址。（如 adrr = base +sizeof(XXX)）</p>

<h5>虚拟继承：</h5>

<p>策略是先安排好derived class的不变部分，而后再建立其共享部分。建立共享部分则需要通过一个指向该base class的指针，以访问virtual base class的成员。而不是像以前一样直接根据计算得到的偏移量得到。</p>

<p>因此存在 this->vbtpr->datamember = XXXX;这样的操作。vbptr意为指向虚基类的不变部分的member地址。</p>

<p>注意这里初期c++编译器对虚拟继承的设计，会对class的data member的“不良影响”如下：</p>

<ul>
<li><p>1、每个对象都要为每一个virtual base class背负这额外的指针，来获得对应的虚基类“共享的部分”。(vbptr)。</p></li>
<li><p>2、如果虚拟继承的串链很长，那么间接存取的次数会增多(这里指多个层次的虚继承)，直接影响访问data member的效率。</p></li>
</ul>


<p>我们如何处理这两个问题？使得，<code>1：对象有固定的负担。2：固定的存取时间</code> 。</p>

<p>解决方法有这些：</p>

<p>第1个问题的解决方法：</p>

<p>(在vc9.0中，多一个虚继承的基类，确乎会多一个vbptr，下面的优化貌似没有实现。不知何故！)</p>

<p>微软编译器：在每一个类中，安插一个vbptr指向一个table，这个table包含了对应的虚基类的指针。</p>

<p>Bjarne的做法：使用offset。把virtual base class和 virtual function entry混合在一起，即，vtable使用正值负值来进行“索引”，若是正值，索引得到的是虚函数的地址；若是负值，索引得到的是从基地址（子类对象的）到继承的虚基类member地址的偏移。</p>

<p>如图：<br/>
  <img src="/images/cppvirtualtable.jpg"></p>

<p>一般而言，virtual base class最有效的应用形式是：一个抽象的virtual base，不包含任何data member。</p>

<h5>3.5 对象成员的效率(Object Member Efficiency)（略过）</h5>

<h5>3.6 指向data member 的指针</h5>

<p>对于指向 nonstatic data member 的指针（如：&amp; Point3d::z），实际上是nonstatic data member在 class中的偏移量(注意：不能说成是class object中的偏移量)；更确切的说是 offset +1——也就是说，位于object 头部的成员对应的data member pointer 的值为1。但是，若对于取已经绑定于对象上的data member(如：&amp;origin.z)，取得的是在内存中实实在在的地址。</p>

<p>这种位移从1开始的特性是基于如下考虑的：如何区分&#8221;没有指向任何data member&#8221;的data member pointer 和 &ldquo;指向第一个data member &#8220;的data member pointer。</p>

<p>注意以上的位移1的处理，编译器已经计算得符合“通常思考原则”。1的额外计算，不需要程序员担心。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Categories</h1>
  <ul id="categories">
    <li class='category'><a href='/blog/categories/cpp/'>cpp (5)</a></li>
<li class='category'><a href='/blog/categories/ios/'>ios (7)</a></li>

  </ul>
</section><section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/09/15/use-reactivecocoa/">use ReactiveCocoa</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/">谈谈iOS中的多屏幕显示</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan/">谈谈iOS中的VCTransition发展</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/25/iosshou-shi-he-uishi-jian-chuan-di-de-chong-chong-xi-jie/">iOS手势和UI事件传递的种种细节</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/08/24/ios7zhong-ui-trick/">edgesForExtendedLayout、automaticallyAdjustsScrollViewInsets和extendedLayoutIncludesOpaqueBars</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - chesterlee -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
  - <span class="credit">Theme by <a href="http://www.gehaxelt.in">Gehaxelt</a></span>
  <span class="credit">and <a href="http://www.it-solutions-neef.de">IT Solutions Neef</a></span>
</p>

</footer>
  











</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Chesterlee's Zen]]></title>
  <link href="http://chesterlee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://chesterlee.github.io/"/>
  <updated>2014-10-20T22:55:04+08:00</updated>
  <id>http://chesterlee.github.io/</id>
  <author>
    <name><![CDATA[chesterlee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Autolayout中的接口释义]]></title>
    <link href="http://chesterlee.github.io/blog/2014/10/13/the-interface-of-the-autolayout/"/>
    <updated>2014-10-13T21:48:18+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/10/13/the-interface-of-the-autolayout</id>
    <content type="html"><![CDATA[<p>下面是对最新iOS8sdk中Autolayout的category接口的解释，如果有错误，希望指正，谢谢！</p>

<h5>UIConstraintBasedLayoutInstallingConstraints—-约束的添加和删除</h5>

<pre><code>-(void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);    //添加约束  
-(void)addConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0);             //添加约束集合
-(void)removeConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0); //移除约束 
-(void)removeConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0);          //移除约束集合       
</code></pre>

<h5>UIConstraintBasedLayoutCoreMethods—-约束的核心函数</h5>

<pre><code>-(void)updateConstraintsIfNeeded NS_AVAILABLE_IOS(6_0);  //立即更新约束
-(void)updateConstraints NS_AVAILABLE_IOS(6_0);//更新约束的接口，可以overrite来更新你特别需要更新的约束
-(BOOL)needsUpdateConstraints NS_AVAILABLE_IOS(6_0);   //查询是否当前view需要更新约束
-(void)setNeedsUpdateConstraints NS_AVAILABLE_IOS(6_0);// 标记需要更新约束，在下一个cycle的时候，run一次约束更新业务流程
</code></pre>

<h5>UIConstraintBasedCompatibility—-约束特性的打开和关闭</h5>

<pre><code>//查询当前是否使用的Autoresizing 
- (BOOL)translatesAutoresizingMaskIntoConstraints NS_AVAILABLE_IOS(6_0);  

//如果手动添加约束，就需要call这个接口，默认的view是添加了autoresizing mask的，
此时需要把他关闭，把此方法的flag传递为NO即可。但是SB/Xib会自动帮你做这个事情。
仅仅手动添加约束需要。 
- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag NS_AVAILABLE_IOS(6_0);

//约束的Layout方式是lazily使用的。如果你在-updateConstraints中来初始化你的约束，
但是如果没有添加约束的话，系统就不会调用这个-updateConstraints接口。
这个就是鸡和蛋的问题，所以用这个方法在自定义的view中返回YES，表示一定要用AL来约束。
比如在一个Cell内部，如果在-updateConstraints进行了constraint的更新，添加删除等，
那么就调用此接口。  
+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);
</code></pre>

<h5>UIConstraintBasedLayoutLayering（baselayout）</h5>

<pre><code>//设置view在当前Frame下对应的alignmentRect的值，这个是AL系统回调函数  
- (CGRect)alignmentRectForFrame:(CGRect)frame NS_AVAILABLE_IOS(6_0);

//设置view在当前alignmentRect下对应的frame的值，这个是AL系统回调函数  
- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect NS_AVAILABLE_IOS(6_0);

// 设置当前view计算alignment rect所需要用到UIEdgeInsets值，比较常用  
- (UIEdgeInsets)alignmentRectInsets NS_AVAILABLE_IOS(6_0); 

// 使用baseline对齐的约束layout时。当前的自定义view告诉AL到底是以本view
的哪个来做对齐的（返回当前view的subview，就以这个subview做基线对齐），
或则是本view自己（这个是默认的对齐方法情况）  
- (UIView *)viewForBaselineLayout NS_AVAILABLE_IOS(6_0);

// 默认的IntrinsicSize使用的value，为(UIViewNoIntrinsicMetric,UIViewNoIntrinsicMetric)，也就是(-1, -1)// -1  
UIKIT_EXTERN const CGFloat UIViewNoIntrinsicMetric NS_AVAILABLE_IOS(6_0);

// 当前view展示其内容的最小的size
- (CGSize)intrinsicContentSize NS_AVAILABLE_IOS(6_0);

// 刷新展示其内容的最小的size，这个要自己主动call，否则系统无法检测。   
- (void)invalidateIntrinsicContentSize NS_AVAILABLE_IOS(6_0);

//获取当前view在axis方向上的抗拉伸优先级  
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0); 

//设置当前view在axis方向上的抗拉伸优先级   
- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);      

//获取当前view在axis方向上的抗压缩优先级
- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);  

//设置当前view在axis方向上的抗压缩优先级  
- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
</code></pre>

<h5>UIConstraintBasedLayoutFittingSize(Autolaytou的size计算)</h5>

<pre><code>// 一个标记，按可以展示内容最小的压缩大小来Layout对应的size（常用）  
UIKIT_EXTERN const CGSize UILayoutFittingCompressedSize NS_AVAILABLE_IOS(6_0);  

//一个标记，按可以展示内容可扩张最大的大小来Layout对应的size，没查到是以怎样的标准来计算的  
UIKIT_EXTERN const CGSize UILayoutFittingExpandedSize NS_AVAILABLE_IOS(6_0);

//配合UILayoutFittingCompressSize和UILayoutFittingExpandedSize来使用，
在当前view的subviews的intrinsic size都可以计算的情况下，可以获取最小压缩（UILayoutFittingCompressSize）
的size或最大（UILayoutFittingExpandedSize）的size。  

- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize NS_AVAILABLE_IOS(6_0);   

//在两个方向上做不同类型的Fit size计算，相对而言，systemLayoutSizeFittingSize是在两个方向上都一致
（都是Compressed或都是Expanded）的用法。  
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority NS_AVAILABLE_IOS(8_0);
</code></pre>

<h5>UIConstraintBasedLayoutDebugging(AutoLayout调试使用)</h5>

<pre><code>//影响当前方向的约束集合  
- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

//是否含有含糊不清的约束 
- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(6_0); 

//待整理  
- (void)exerciseAmbiguityInLayout NS_AVAILABLE_IOS(6_0);  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈在UIWebView中的内存控制]]></title>
    <link href="http://chesterlee.github.io/blog/2014/10/07/control-memory-in-uiwebview/"/>
    <updated>2014-10-07T21:05:05+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/10/07/control-memory-in-uiwebview</id>
    <content type="html"><![CDATA[<p>本文是一个webView内存管理的trick，可以直接拿来用。<br/>
由于UIWebView的内容加载不受程序员直接控制，所以在UIWebView加载一些图片较多的网页时，如果图片较多，很容易就在网页读取阶段出现memory warning，而且当你把webview对象干掉时，内存依然不减。如果不处理的话，程序就会被kill掉。如何处理呢，下面是几个tip可以让君尝试：</p>

<p>1、在每一次UIWebView读取页面结束后(Delegate)，调用UserDefault关闭缓存。代码：</p>

<pre><code>   - (void)webViewDidFinishLoad:(UIWebView *)webView 
   {
     [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:@"WebKitCacheModelPreferenceKey"];  
   } 
</code></pre>

<p>注意，不必担心这个WebKitCacheModelPreferenceKey会一直保持为0。因为每一次UIWebView加载页面的时候，都会把此值设置为1。</p>

<p>2、在离开webview的controller时，使用WebView加载nil的URL，并清理webview。</p>

<pre><code>-(void)viewDidDisappear:(BOOL)animated
{
  [super viewDidDisappear:animated];
  [self.webView loadRequest:nil];
  [self.webView removeFromSuperview];
  self.webView = nil;
  self.webView.delegate = nil;
  [self.webView stopLoading];
} 
</code></pre>

<p>3、在收到系统警告的时候，清理NSURLCache的CachedResponse。</p>

<pre><code>-(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  [self.navigationController setNavigationBarHidden:NO];
} 
</code></pre>

<p>trick结束:)。 <br/>
本文参考：<br/>
1、<a href = http://twobitlabs.com/2012/01/ios-ipad-iphone-nsurlcache-uiwebview-memory-utilization/>Reduce iOS memory utilization by taming NSURLCache</a><br/>
2、<a href = http://www.codercowboy.com/code-uiwebview-memory-leak-prevention/>UIWebView Memory Leak Prevention </a><br/>
3、<a href = http://blog.techno-barje.fr//post/2010/10/04/UIWebView-secrets-part1-memory-leaks-on-xmlhttprequest/>UIWebView Secrets &ndash; Part1 &ndash; Memory Leaks on Xmlhttprequest </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ReactiveCocoa]]></title>
    <link href="http://chesterlee.github.io/blog/2014/09/15/use-reactivecocoa/"/>
    <updated>2014-09-15T22:21:07+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/09/15/use-reactivecocoa</id>
    <content type="html"><![CDATA[<p>本篇的文章的目的很明确，就是要会使用RAC。这里对RAC的关键概念和行为做出较为清晰的说明，便于使用。</p>

<p>ReactiveCocoa衍生自FRP（响应链编程）的一种，它是用OC语言来描述FRP的一个框架。其根源可以追述到如下论坛：<a href= http://www.haskell.org/haskellwiki/Haskell>Haskell</a></p>

<p>要会使用RAC，首先要了解FRP，了解了响应链编程之后，才可以顺利的使用RAC。PS：其实回过头来思考，RAC使用的语言和方法并不重要，重要的是这些概念。如果后续要转入Swift的FRP，也是一样。</p>

<p>核心概念：</p>

<ul>
<li><p>信号(Signal)：信号是RAC的核心。我的理解是，在RAC的编码中，对于数据的反射式响应传输，都是以信号为基础来实现的。没有它，就没有响应式自动化。</p></li>
<li><p>订阅者 (Subscriber)：订阅者是使信号有效的一个重要角色。在FRP中，一个信号创建之后，是没有意义的，此时它不知道给谁传送数据，此时它是Cold的。而只有当他被一个或多个Subscriber订阅之后，信号接到事件源之后，就会触发响应，并发送数据给订阅者。</p></li>
</ul>


<p>通常的使用做法是：<br/>
a、使用一个既有信号(RAC已经给你wrapper好的Category)，然后使用匿名subscriber去做订阅行为，获取到next送来的值，或者error、completed的block，来做相应的业务逻辑操作。<br/>
b、如果自己要自定义信号，则需要通过create信号的方式，建立一个信号，在这个信号中执行数据获取、异步计算等操作，并在信号中发送sendNext、sendCompleted或sendError等数据或行为。注意，在sendNext中发送的数据，就是subscriber接到的数据。</p>

<p>另外，对于FRP而言，最为重要的就是信号和信号之间的关系：filter、flattenMap、CombineLatest、takeUntil、then等处理。下面简要说明下：</p>

<ul>
<li>filter：信号过滤，用于判断信号返回值的业务合法性。只有合法的信号，才可以被继续向下输送。</li>
<li>flattenMap(Map)：信号映射，可以将信号的发送过来的值重新计算，并以一个新值发送出去。</li>
<li>CombineLatest：是将多个信号合并为一个信号，但是这个信号承载的value是多个信号返回的value。</li>
<li>takeUntil：一个信号是一直hot的，但是当另外一个信号有效时，它就会失效。</li>
<li>then：当某个信号结束后，可以用then来继续后续的wapper，返回或新生成一个新的signal，来继续操作。</li>
</ul>


<p>ReactiveCocoa还支持对系统Event、Notification、liftSelector、多线程、timer等处理。</p>

<p>我们可以看到，RAC可以在不影响原有业务逻辑的情况下，新增新的更复杂的业务逻辑。象积木一样不断积累和可扩展。而完全不必要地新增状态变量，让原有的代码发生更改。</p>

<p>本文只讲解比较关键的几个概念，详细的概念可以参看下面的文章，代码可以看看文中具体的使用也可以见<a href = https://github.com/chesterlee/UseRAC>UseRAC</a>中的代码。</p>

<p>文中的概念参考文章有：<br/>
1、<a href = http://www.infoq.com/cn/articles/functional-reactive-programming>函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a><br/>
2、<a href = https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa in github</a><br/>
3、<a href = http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/>Getting Started with ReactiveCocoa</a><br/>
4、<a href = http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1>MVVM Tutorial with ReactiveCocoa: Part &frac12;</a><br/>
5、<a href = http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2>MVVM Tutorial with ReactiveCocoa: Part 2/2 </a><br/>
6、<a href = http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html>ReactiveCocoa2实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈iOS中的多屏幕显示]]></title>
    <link href="http://chesterlee.github.io/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/"/>
    <updated>2014-08-28T21:15:49+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi</id>
    <content type="html"><![CDATA[<p>最近接到需要进行ipad通过Apple TV进行多屏显示的需求，所以研究了下，可以在自己App中对外部荧幕进行Mirror和Different Content的切换。如果你没玩过，实在是有些可惜，不妨往下看看：</p>

<h4>初步的概念</h4>

<p>iOS App中UIWindow通常包含了App的view，连通了当前的硬件设备。而和Window联系到一起的Screen代表了特定使用的显示内容。如果你的app允许用户使用外接显示器，我们就需要创建一个UIWIndow对象来管理对外界显示器的展示。</p>

<h4>要显示内容到外部屏幕？请添加UIWindow</h4>

<p>如果你要支持外屏显示，你需要建立另外一个不同的window对象，从而让这个UIWindow对象展示的内容投射放到外部设备上。默认你可以在两个window上展示相同的内容，因为他们默认是mirroring的。当然，你可以把这个mirroring关闭了，赋值为nil或初始化一个UIWIndow到上面去。</p>

<h4>Window和Screen的概念</h4>

<p>先说说UIWindow，它组合了所有需要显示的ViewTree，并负责对subview的展示，组织他们的继承体系，以及对它们的事件传递。通常每一个App都有一个window对象来展示app自己的UI（在iOS设备上）。如果有外部显示器链接到设备上，那么app就可以使用第二个window来进行大荧幕数据的展示。<br/>
再说说UIScreen对象，对于UIWindow而言，每一个UIWindow中有一个UIScreen对象。UIScreen对象抽象地描述了一个具体显示设备的信息：bounds、mode、brightness等。你也可以监听各种消息，比如连接上显示器了，断开显示器了，显示器亮度调整了等的消息。</p>

<h4>Window和Screen的其他用途</h4>

<p>1、通过UIWindow来调整Window的亮度。还有wantsSoftwareDimming等等。
2、通过UIScreen displayLinkWithTarget:selector: 接口来在runloop进行CoreAnimation每一帧的绘制，或使用OpenGL es直接绘制。</p>

<h4>StoryBoard做了点事情</h4>

<p>使用Storyboard，建立默认的VC。它就帮你做了下面几件事情：</p>

<ul>
<li>Instantiates a window. （初始化Window）</li>
<li>Loads the main storyboard and instantiates its initial view controller. (初始化Storyboard中的initial VC)</li>
<li>Assigns the new view controller to the window’s rootViewController property and then makes the window visible.(把initial VC作为UIWindow中的RootVC，然后让Window可见)</li>
</ul>


<h4>外接显示器的实际做法</h4>

<p>默认的iOS行为：Mirror。如果默认什么都不处理，那么对于一个App而言，它的内容是直接镜像到荧幕上的。除非你要显示和iOS设备荧幕不一样的内容，你可以这样做：</p>

<ul>
<li>程序一启动，就要检查外部显示器的存在。并且注册Screen的连接和断开连接的Notification。</li>
<li>当外部显示器可用了，无论是程序启动检测，还是收到Screen连接的Notification，你都要创建并且配置一个UIWindow给这个外部设备。</li>
<li>连接这个UIWindow和这个合适的UIScreen对象，展示第二个UIWindow，并更新。</li>
</ul>


<p>BTW：如果要开启镜像，请把多出来的UIWindow给干掉就好了。</p>

<h4>代码时间</h4>

<p>好，接下来是代码时间，上面3步的代码如下：<br/>
1、当外部设备Ready的时候，创建一个UIWindow匹配外部抽象的UIScreen对象。</p>

<pre><code>- (void)checkForExistingScreenAndInitializeIfPresent
{
   if ([[UIScreen screens] count] &gt; 1)
  {
     UIScreen *secondScreen = [[UIScreen screens] objectAtIndex:1];
     CGRect screenBounds = secondScreen.bounds;
     self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
     self.secondWindow.screen = secondScreen;
     self.secondWindow.hidden = NO;
  } 
}
</code></pre>

<p>注意：UIWindow最好先和UIScreen连接起来，然后再显示UIWindow的内容，最好不要先显示UIWindow的内容，再链接UIScreen。因为非常耗资源。</p>

<p>2、注册Screen的连接和断开事件</p>

<pre><code> - (void)setUpScreenConnectionNotificationHandlers
{
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    [center addObserver:self selector:@selector(handleScreenDidConnectNotification:) name:UIScreenDidConnectNotification object:nil];
    [center addObserver:self selector:@selector(handleScreenDidDisconnectNotification:)
}
</code></pre>

<p>3、处理断开和连接的事件</p>

<pre><code>- (void)handleScreenDidConnectNotification:(NSNotification*)aNotification
{
   UIScreen *newScreen = [aNotification object];
   CGRect screenBounds = newScreen.bounds;
   if (!self.secondWindow)
   {
    self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
    self.secondWindow.screen = newScreen;
   }
}

- (void)handleScreenDidDisconnectNotification:(NSNotification*)aNotification
{
  if (self.secondWindow)
  {
    // Hide and then delete the window.
    self.secondWindow.hidden = YES;
    self.secondWindow = nil;
  }
}
</code></pre>

<p> 以上代码也可以在水果文档的多屏编码指南中找到。其实这只是一个开始，表明自己Create的UIWindow可以以抽象的方式来在外部显示器上展示，至于不断添加业务逻辑，肯定需要更好的代码封装。最后说一句，水果文档建议在AppDelegate中进行Screen的监听，其实可以按需求来进行工作。大概就这样啦。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈iOS中的VCTransition发展]]></title>
    <link href="http://chesterlee.github.io/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan/"/>
    <updated>2014-08-26T21:19:13+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/08/26/tan-tan-ioszhong-de-vctransitionfa-zhan</id>
    <content type="html"><![CDATA[<h2>前言</h2>

<p>iOS的VCTransition一直是在跟着iOS不断变化着的，最大的感觉就是不断地解耦，动画之间VC的关联变得薄弱，或者都抽象到一个统一的位置，进行处理。下面都说下：</p>

<h4>Navigation、TabBar等切换</h4>

<p>  这个是最早(传统的)的VC风格了。比如使用如下代码：</p>

<pre><code>  -(IBAction)PushA:(id)sender 
  {  
     UIStoryboard *story = [UIStoryboard storyboardWithName:@"Main" bundle:nil];
     AViewController *aVC = [story instantiateViewControllerWithIdentifier:@"AVCID"];  
     [self.navigationController pushViewController:aVC animated:YES]; 
  }
</code></pre>

<p>  这个方法是使用Navigation来管理VCs的一个Transition方式。比较简单，直接。但是耦合性比较大，在VC中必须知道自己要跳转到对应到VC，而且动画要写到对应的VC中，如果动画复杂，会很容易造成VC臃肿起来。</p>

<h4>VC容器的Transition</h4>

<p>由于iOS5.0后续版本新增了自定义的VC容器，那么从在容器中进行child vc之间到转场，会有专门的方法。比如如下代码:</p>

<pre><code>  [self transitionFromViewController:self.goodsCollectionVC
                  toViewController:self.mainPageVC
                          duration:SWITCH_VCS_TIME
                          options:UIViewAnimationOptionTransitionCrossDissolve animations:^{
                  // do animation things
} completion:^(BOOL finished) {
    // do animation completion things
}];
</code></pre>

<p>这个方法在容器中切换subVC比较方便，但是只实现了简单的Transition动画，并且依然是有耦合的。因为Container做动画的切换VC的时候，如果动画非常复杂，依然会有动画无法复用的状况。</p>

<h4>StoryBoard和Segue</h4>

<p>  这个是iOS5时提供的转场方式：通过在Storyboard中或代码中定义Push、Modal或 Custom segue，定义一个SegueID，然后需要做Transition的时候，去Perform一个Segue就可以了，代码如下：</p>

<pre><code>  [self performSegueWithIdentifier:@"PushSegueID" sender:self];  
</code></pre>

<p>在执行动画之前，自己的VC就要做些preparation可以在如下代码中调用</p>

<pre><code>  -(void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender NS_AVAILABLE_IOS(5_0){} 
</code></pre>

<p>  特别需要说一下，如果动画处理复杂的，通过Custom Segue，就可以把动画挪到自定义segue中，降低sourceVC的代码量，动画也可以解耦甚至抽象。主要步骤就有两个：<br/>
  &ndash; 在Storybaord或代码中实例化自定义的segue。
  &ndash; 自定义Segue类复写perform方法。<br/>
  关键代码如下：</p>

<pre><code>   -(void)perform
   {
      id sourceVC = self.sourceViewController;
      id destVC = self.destinationViewController;
      //Do animation  
    }
</code></pre>

<p> segue 最关键的两个property，一个是sourceViewController，一个是destinationViewController，就实现一个动画而言，这两个变量就够了。</p>

<h4>iOS7的Transition</h4>

<p>iOS7提供了新的transition方式。默认提供了Present和Push的抽象动画，新增了percent的手势交互动画。例如，如果要自定义navigation push的动画就可以实现一个支持UIViewControllerAnimatedTransitioning的对象。在这个transition对象中，来设计自己的动画。和segue类似，代码可见：</p>

<pre><code>   -(void)animateTransition:(id &lt;UIViewControllerContextTransitioning&gt;)transitionContext
   {
        UIViewController *destController =  [transitionContext viewControllerForKey:UITransitionContextToViewControllerKey];  
        UIViewController *fromController =  [transitionContext viewControllerForKey:UITransitionContextFromViewControllerKey];
        UIView *containerView = [transitionContext containerView];  
        [containerView addSubview:destController.view];
   }
</code></pre>

<p>和Segue相同的是，都可以通过对象来获取Source和DestinationVC。不同的是，iOS7新提供的Transition提供了ContainerView，来做动画交互的容器。<br/>
对于外部而言，在代理中制定对应的Custom Transition对象即可使用他们了，可定制化更高：<br/>
比如在VC Controller中实例化对应的代理方法：</p>

<pre><code>   -(id &lt;UIViewControllerAnimatedTransitioning&gt;)navigationController:(UINavigationController *)navigationController
                               animationControllerForOperation:(UINavigationControllerOperation)operation
                                            fromViewController:(UIViewController *)fromVC
                                              toViewController:(UIViewController *)toVC
                                         {
                                            if (someCondition) 
                                            {
                                              _naviTransitioning.operation = operation;
                                              return  _naviTransitioning;
                                            }
                                            return nil;
                                          }
</code></pre>

<p>至于iOS7的UIPercentDrivenInteractiveTransition，这里不展开讲了，具体可以搜搜相关文档。<br/>
经过Transition的不断强化，iOS7新增的Transition，大大增强了动画的复用性，降低了耦合度，增加了交互性，给编码人员提供更多福利。</p>
]]></content>
  </entry>
  
</feed>

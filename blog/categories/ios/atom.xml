<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Chesterlee's Zen]]></title>
  <link href="http://chesterlee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://chesterlee.github.io/"/>
  <updated>2014-11-26T22:02:36+08:00</updated>
  <id>http://chesterlee.github.io/</id>
  <author>
    <name><![CDATA[chesterlee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[AutoLayout中的约束]]></title>
    <link href="http://chesterlee.github.io/blog/2014/10/30/the-core-concept-of-the-autolayout/"/>
    <updated>2014-10-30T21:03:40+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/10/30/the-core-concept-of-the-autolayout</id>
    <content type="html"><![CDATA[<p>前段时间一直很忙，没有时间把AL的东西拿来总结下，今天整理下约束：</p>

<h3>约束的类型</h3>

<p>对于Autolayout而言，最为核心的基础就是约束。那么在iOS中约束到底有几种？它们有那些作用呢？下面说下。</p>

<ul>
<li><p><strong>NSLayoutConstraint</strong>，开放类，几乎是程序员最常用的约束。它用于设置view在view tree之间的关系，自身大小等。</p></li>
<li><p><strong>NSContentSizeLayoutConstraint</strong>，私有类。用于衡量view内容和大小相关的约束。比如Hugging和Compression，控制view的内容显示。</p></li>
<li><p><strong>NSAutoresizingMaskLayoutConstraint</strong>，私有 类。由Autosizing mask转换到Autolayout系统中的约束表达。</p></li>
<li><p><strong>_UILayoutSupportConstraint</strong>，私有类。布局支撑约束，它包括Top和Bottom的约束，用于控制view的显示边界，例如，它限制view的顶端显示不会和状态栏重合。</p></li>
<li><p><strong>NSIBPrototypingLayoutConstraint</strong>，私有类。如果你丫在Storyboard中添加了一个UI控件，且没有在Storyboard中添加任何约束，但是标注了你要使用Autolayout，那么在实际的运行期，系统会默认为它添加NSIBPrototypingLayoutConstraint约束。</p></li>
</ul>


<p>值得一提的是：NSContentSizeLayoutConstraint最主要的作用是和intrinsic size一起工作，通常这个约束和Layout约束共同决定view的显示方式。</p>

<h3>约束优先级</h3>

<p>这里不去介绍约束优先级有哪些枚举值，而是说明它存在的意义：它通常是形容一个约束重要性的指标，通常两个约束如果共同决定一个显示属性的显示，当他们发生了抵触的时候，优先级表示其中一个约束，相比另外一个而言，更加重要。</p>

<p>另外，<strong>优先级就是浮点数，通常用其整数表达</strong>。</p>

<h3>ContentSize约束</h3>

<p>AL系统有根据显示内容来自适应尺寸的能力。这个能力是由，Intrinsic Content Size内容大小、content hugging约束、content compression约束来共同决定。</p>

<h4>intrinsic size</h4>

<p>Intrinsic Content Size保证了当view的内容变化后，自己适应内容的大小的描述。</p>

<p>自定义View需要自己计算适合自己的intrinsic size。而imageview、label等含有内容控件(除了UITextView)都会自己计算"适合内容的Size"，文档没有提是minSize来fit其中的Content，我就没这么写，不过应该可以这样理解。</p>

<h4>Content Hugging</h4>

<p>抗拉伸属性。其实它是一个约束，它使得它本身的大小更加贴合显示的内容。例如：如果一个UIView的内容显示需要200的宽度，那么如果UIView本身有宽度约束(此约束设置宽度为400)，此时若抗拉伸属性的优先级比宽度约束要高，View本身的大小就不会变化，反之就会被拉伸。</p>

<h4>Compression Resistance</h4>

<p>抗压缩属性。它的一切和抗拉伸相反。</p>

<h4>Layout Constraints</h4>

<p>其实Layout约束是程序员必须熟悉的。一个线性公式就说明了它的意义：</p>

<pre><code>view1.attr1 = view2.attr2 * multiplier + constant  
</code></pre>

<p>这里=可以是>=，&lt;=，&lt;，>等。</p>

<p>剩余就是描述Layout Constraint的<strong>生成和装载方式</strong>：</p>

<p>生成方式比如:Layout Constraints的描述方式可以是原生NSLayoutConstraint来实现，也可以是VFL，也可以是自己封装的库。
这里要进一步明确一个概念：约束是一种概念，它说明了一种关系。</p>

<h4>约束的装载方式</h4>

<p>1、View形容它自己的约束(一元约束)，添加到自己或者直系SuperView中。<br/>
2、View和View之间的约束，如果view之间是父子关系，添加到父亲上。如果view和view是兄弟关系，则添加到他们共同的父亲节点上。<br/>
3、View和View之间的约束，如果他们是两个不同的分支上的，则需要把约束添加到他们共同的祖先上面。<br/>
相信这样说应该比较清晰了。</p>

<h4>约束的比较</h4>

<p>通常而言，比较对象，需要比较一个对象的所有成员变量，如果一一相等，则表明他们相等。
但是，对于约束而言，这个比较方式比较例外：除了优先级以外的参数都要一致，才是一样的约束。也就是说优先级是不需要参与比较的。例如：</p>

<pre><code>- (BOOL) isEqualToConstraint: (NSLayoutConstraint *) constraint 
{
      if (self.firstItem != constraint.firstItem) return NO;
      if (self.secondItem != constraint.secondItem) return NO;
      if (self.firstAttribute != constraint.firstAttribute) return NO; 
      if (self.secondAttribute != constraint.secondAttribute) return NO; 
      if (self.relation != constraint.relation) return NO;
      if (self.multiplier != constraint.multiplier) return NO;
      if (self.constant != constraint.constant) return NO;
      return YES; 
}
</code></pre>

<h3>约束使用的几个建议</h3>

<p>1、充分利用约束的优先级。不要把什么约束的优先级都搞成Require。<br/>
2、约束没有顺序而言。优先级越高越会得到满足。<br/>
3、看上去有问题的，在iOS7和iOS8的AL系统对于Transform的行为，不太一致。transform的先后顺序不一致，有兴趣的朋友可以试试。<br/>
4、不要无聊地建立一个ScrollView内部的view和Scrollview外部的view的约束。<br/>
5、请注意UpdateConstraint、Layoutsubview、DrawRect的顺序，在这个管线中的特定阶段做自己想自定义的事情。<br/>
6、注意约束描述的合理性，以避免自我矛盾的描述引起的Layout约束的冲突、歧义甚至崩溃。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Autolayout中的接口释义]]></title>
    <link href="http://chesterlee.github.io/blog/2014/10/13/the-interface-of-the-autolayout/"/>
    <updated>2014-10-13T21:48:18+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/10/13/the-interface-of-the-autolayout</id>
    <content type="html"><![CDATA[<p>下面是对最新iOS8sdk中Autolayout的category接口的解释，如果有错误，希望指正，谢谢！</p>

<h5>UIConstraintBasedLayoutInstallingConstraints—-约束的添加和删除</h5>

<pre><code>-(void)addConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0);    //添加约束  
-(void)addConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0);             //添加约束集合
-(void)removeConstraint:(NSLayoutConstraint *)constraint NS_AVAILABLE_IOS(6_0); //移除约束 
-(void)removeConstraints:(NSArray *)constraints NS_AVAILABLE_IOS(6_0);          //移除约束集合       
</code></pre>

<h5>UIConstraintBasedLayoutCoreMethods—-约束的核心函数</h5>

<pre><code>-(void)updateConstraintsIfNeeded NS_AVAILABLE_IOS(6_0);  //立即更新约束
-(void)updateConstraints NS_AVAILABLE_IOS(6_0);//更新约束的接口，可以overrite来更新你特别需要更新的约束
-(BOOL)needsUpdateConstraints NS_AVAILABLE_IOS(6_0);   //查询是否当前view需要更新约束
-(void)setNeedsUpdateConstraints NS_AVAILABLE_IOS(6_0);// 标记需要更新约束，在下一个cycle的时候，run一次约束更新业务流程
</code></pre>

<h5>UIConstraintBasedCompatibility—-约束特性的打开和关闭</h5>

<pre><code>//查询当前是否使用的Autoresizing 
- (BOOL)translatesAutoresizingMaskIntoConstraints NS_AVAILABLE_IOS(6_0);  

//如果手动添加约束，就需要call这个接口，默认的view是添加了autoresizing mask的，
此时需要把他关闭，把此方法的flag传递为NO即可。但是SB/Xib会自动帮你做这个事情。
仅仅手动添加约束需要。 
- (void)setTranslatesAutoresizingMaskIntoConstraints:(BOOL)flag NS_AVAILABLE_IOS(6_0);

//约束的Layout方式是lazily使用的。如果你在-updateConstraints中来初始化你的约束，
但是如果没有添加约束的话，系统就不会调用这个-updateConstraints接口。
这个就是鸡和蛋的问题，所以用这个方法在自定义的view中返回YES，表示一定要用AL来约束。
比如在一个Cell内部，如果在-updateConstraints进行了constraint的更新，添加删除等，
那么就调用此接口。  
+ (BOOL)requiresConstraintBasedLayout NS_AVAILABLE_IOS(6_0);
</code></pre>

<h5>UIConstraintBasedLayoutLayering（baselayout）</h5>

<pre><code>//设置view在当前Frame下对应的alignmentRect的值，这个是AL系统回调函数  
- (CGRect)alignmentRectForFrame:(CGRect)frame NS_AVAILABLE_IOS(6_0);

//设置view在当前alignmentRect下对应的frame的值，这个是AL系统回调函数  
- (CGRect)frameForAlignmentRect:(CGRect)alignmentRect NS_AVAILABLE_IOS(6_0);

// 设置当前view计算alignment rect所需要用到UIEdgeInsets值，比较常用  
- (UIEdgeInsets)alignmentRectInsets NS_AVAILABLE_IOS(6_0); 

// 使用baseline对齐的约束layout时。当前的自定义view告诉AL到底是以本view
的哪个来做对齐的（返回当前view的subview，就以这个subview做基线对齐），
或则是本view自己（这个是默认的对齐方法情况）  
- (UIView *)viewForBaselineLayout NS_AVAILABLE_IOS(6_0);

// 默认的IntrinsicSize使用的value，为(UIViewNoIntrinsicMetric,UIViewNoIntrinsicMetric)，也就是(-1, -1)// -1  
UIKIT_EXTERN const CGFloat UIViewNoIntrinsicMetric NS_AVAILABLE_IOS(6_0);

// 当前view展示其内容的最小的size
- (CGSize)intrinsicContentSize NS_AVAILABLE_IOS(6_0);

// 刷新展示其内容的最小的size，这个要自己主动call，否则系统无法检测。   
- (void)invalidateIntrinsicContentSize NS_AVAILABLE_IOS(6_0);

//获取当前view在axis方向上的抗拉伸优先级  
- (UILayoutPriority)contentHuggingPriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0); 

//设置当前view在axis方向上的抗拉伸优先级   
- (void)setContentHuggingPriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);      

//获取当前view在axis方向上的抗压缩优先级
- (UILayoutPriority)contentCompressionResistancePriorityForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);  

//设置当前view在axis方向上的抗压缩优先级  
- (void)setContentCompressionResistancePriority:(UILayoutPriority)priority forAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);
</code></pre>

<h5>UIConstraintBasedLayoutFittingSize(Autolaytou的size计算)</h5>

<pre><code>// 一个标记，按可以展示内容最小的压缩大小来Layout对应的size（常用）  
UIKIT_EXTERN const CGSize UILayoutFittingCompressedSize NS_AVAILABLE_IOS(6_0);  

//一个标记，按可以展示内容可扩张最大的大小来Layout对应的size，没查到是以怎样的标准来计算的  
UIKIT_EXTERN const CGSize UILayoutFittingExpandedSize NS_AVAILABLE_IOS(6_0);

//配合UILayoutFittingCompressSize和UILayoutFittingExpandedSize来使用，
在当前view的subviews的intrinsic size都可以计算的情况下，可以获取最小压缩（UILayoutFittingCompressSize）
的size或最大（UILayoutFittingExpandedSize）的size。  

- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize NS_AVAILABLE_IOS(6_0);   

//在两个方向上做不同类型的Fit size计算，相对而言，systemLayoutSizeFittingSize是在两个方向上都一致
（都是Compressed或都是Expanded）的用法。  
- (CGSize)systemLayoutSizeFittingSize:(CGSize)targetSize withHorizontalFittingPriority:(UILayoutPriority)horizontalFittingPriority verticalFittingPriority:(UILayoutPriority)verticalFittingPriority NS_AVAILABLE_IOS(8_0);
</code></pre>

<h5>UIConstraintBasedLayoutDebugging(AutoLayout调试使用)</h5>

<pre><code>//影响当前方向的约束集合  
- (NSArray *)constraintsAffectingLayoutForAxis:(UILayoutConstraintAxis)axis NS_AVAILABLE_IOS(6_0);

//是否含有含糊不清的约束 
- (BOOL)hasAmbiguousLayout NS_AVAILABLE_IOS(6_0); 

//待整理  
- (void)exerciseAmbiguityInLayout NS_AVAILABLE_IOS(6_0);  
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈在UIWebView中的内存控制]]></title>
    <link href="http://chesterlee.github.io/blog/2014/10/07/control-memory-in-uiwebview/"/>
    <updated>2014-10-07T21:05:05+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/10/07/control-memory-in-uiwebview</id>
    <content type="html"><![CDATA[<p>本文是一个webView内存管理的trick，可以直接拿来用。<br/>
由于UIWebView的内容加载不受程序员直接控制，所以在UIWebView加载一些图片较多的网页时，如果图片较多，很容易就在网页读取阶段出现memory warning，而且当你把webview对象干掉时，内存依然不减。如果不处理的话，程序就会被kill掉。如何处理呢，下面是几个tip可以让君尝试：</p>

<p>1、在每一次UIWebView读取页面结束后(Delegate)，调用UserDefault关闭缓存。代码：</p>

<pre><code>   - (void)webViewDidFinishLoad:(UIWebView *)webView 
   {
     [[NSUserDefaults standardUserDefaults] setInteger:0 forKey:@"WebKitCacheModelPreferenceKey"];  
   } 
</code></pre>

<p>注意，不必担心这个WebKitCacheModelPreferenceKey会一直保持为0。因为每一次UIWebView加载页面的时候，都会把此值设置为1。</p>

<p>2、在离开webview的controller时，使用WebView加载nil的URL，并清理webview。</p>

<pre><code>-(void)viewDidDisappear:(BOOL)animated
{
  [super viewDidDisappear:animated];
  [self.webView loadRequest:nil];
  [self.webView removeFromSuperview];
  self.webView = nil;
  self.webView.delegate = nil;
  [self.webView stopLoading];
} 
</code></pre>

<p>3、在收到系统警告的时候，清理NSURLCache的CachedResponse。</p>

<pre><code>-(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  [self.navigationController setNavigationBarHidden:NO];
} 
</code></pre>

<p>trick结束:)。 <br/>
本文参考：<br/>
1、<a href = http://twobitlabs.com/2012/01/ios-ipad-iphone-nsurlcache-uiwebview-memory-utilization/>Reduce iOS memory utilization by taming NSURLCache</a><br/>
2、<a href = http://www.codercowboy.com/code-uiwebview-memory-leak-prevention/>UIWebView Memory Leak Prevention </a><br/>
3、<a href = http://blog.techno-barje.fr//post/2010/10/04/UIWebView-secrets-part1-memory-leaks-on-xmlhttprequest/>UIWebView Secrets &ndash; Part1 &ndash; Memory Leaks on Xmlhttprequest </a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用ReactiveCocoa]]></title>
    <link href="http://chesterlee.github.io/blog/2014/09/15/use-reactivecocoa/"/>
    <updated>2014-09-15T22:21:07+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/09/15/use-reactivecocoa</id>
    <content type="html"><![CDATA[<p>本篇的文章的目的很明确，就是要会使用RAC。这里对RAC的关键概念和行为做出较为清晰的说明，便于使用。</p>

<p>ReactiveCocoa衍生自FRP（响应链编程）的一种，它是用OC语言来描述FRP的一个框架。其根源可以追述到如下论坛：<a href= http://www.haskell.org/haskellwiki/Haskell>Haskell</a></p>

<p>要会使用RAC，首先要了解FRP，了解了响应链编程之后，才可以顺利的使用RAC。PS：其实回过头来思考，RAC使用的语言和方法并不重要，重要的是这些概念。如果后续要转入Swift的FRP，也是一样。</p>

<p>核心概念：</p>

<ul>
<li><p>信号(Signal)：信号是RAC的核心。我的理解是，在RAC的编码中，对于数据的反射式响应传输，都是以信号为基础来实现的。没有它，就没有响应式自动化。</p></li>
<li><p>订阅者 (Subscriber)：订阅者是使信号有效的一个重要角色。在FRP中，一个信号创建之后，是没有意义的，此时它不知道给谁传送数据，此时它是Cold的。而只有当他被一个或多个Subscriber订阅之后，信号接到事件源之后，就会触发响应，并发送数据给订阅者。</p></li>
</ul>


<p>通常的使用做法是：<br/>
a、使用一个既有信号(RAC已经给你wrapper好的Category)，然后使用匿名subscriber去做订阅行为，获取到next送来的值，或者error、completed的block，来做相应的业务逻辑操作。<br/>
b、如果自己要自定义信号，则需要通过create信号的方式，建立一个信号，在这个信号中执行数据获取、异步计算等操作，并在信号中发送sendNext、sendCompleted或sendError等数据或行为。注意，在sendNext中发送的数据，就是subscriber接到的数据。</p>

<p>另外，对于FRP而言，最为重要的就是信号和信号之间的关系：filter、flattenMap、CombineLatest、takeUntil、then等处理。下面简要说明下：</p>

<ul>
<li>filter：信号过滤，用于判断信号返回值的业务合法性。只有合法的信号，才可以被继续向下输送。</li>
<li>flattenMap(Map)：信号映射，可以将信号的发送过来的值重新计算，并以一个新值发送出去。</li>
<li>CombineLatest：是将多个信号合并为一个信号，但是这个信号承载的value是多个信号返回的value。</li>
<li>takeUntil：一个信号是一直hot的，但是当另外一个信号有效时，它就会失效。</li>
<li>then：当某个信号结束后，可以用then来继续后续的wapper，返回或新生成一个新的signal，来继续操作。</li>
</ul>


<p>ReactiveCocoa还支持对系统Event、Notification、liftSelector、多线程、timer等处理。</p>

<p>我们可以看到，RAC可以在不影响原有业务逻辑的情况下，新增新的更复杂的业务逻辑。象积木一样不断积累和可扩展。而完全不必要地新增状态变量，让原有的代码发生更改。</p>

<p>本文只讲解比较关键的几个概念，详细的概念可以参看下面的文章，代码可以看看文中具体的使用也可以见<a href = https://github.com/chesterlee/UseRAC>UseRAC</a>中的代码。</p>

<p>文中的概念参考文章有：<br/>
1、<a href = http://www.infoq.com/cn/articles/functional-reactive-programming>函数式反应型编程(FRP) —— 实时互动应用开发的新思路</a><br/>
2、<a href = https://github.com/ReactiveCocoa/ReactiveCocoa>ReactiveCocoa in github</a><br/>
3、<a href = http://www.teehanlax.com/blog/getting-started-with-reactivecocoa/>Getting Started with ReactiveCocoa</a><br/>
4、<a href = http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1>MVVM Tutorial with ReactiveCocoa: Part &frac12;</a><br/>
5、<a href = http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2>MVVM Tutorial with ReactiveCocoa: Part 2/2 </a><br/>
6、<a href = http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html>ReactiveCocoa2实战</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈iOS中的多屏幕显示]]></title>
    <link href="http://chesterlee.github.io/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi/"/>
    <updated>2014-08-28T21:15:49+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/08/28/tan-tan-ioszhong-de-duo-ping-mu-xian-shi</id>
    <content type="html"><![CDATA[<p>最近接到需要进行ipad通过Apple TV进行多屏显示的需求，所以研究了下，可以在自己App中对外部荧幕进行Mirror和Different Content的切换。如果你没玩过，实在是有些可惜，不妨往下看看：</p>

<h4>初步的概念</h4>

<p>iOS App中UIWindow通常包含了App的view，连通了当前的硬件设备。而和Window联系到一起的Screen代表了特定使用的显示内容。如果你的app允许用户使用外接显示器，我们就需要创建一个UIWIndow对象来管理对外界显示器的展示。</p>

<h4>要显示内容到外部屏幕？请添加UIWindow</h4>

<p>如果你要支持外屏显示，你需要建立另外一个不同的window对象，从而让这个UIWindow对象展示的内容投射放到外部设备上。默认你可以在两个window上展示相同的内容，因为他们默认是mirroring的。当然，你可以把这个mirroring关闭了，赋值为nil或初始化一个UIWIndow到上面去。</p>

<h4>Window和Screen的概念</h4>

<p>先说说UIWindow，它组合了所有需要显示的ViewTree，并负责对subview的展示，组织他们的继承体系，以及对它们的事件传递。通常每一个App都有一个window对象来展示app自己的UI（在iOS设备上）。如果有外部显示器链接到设备上，那么app就可以使用第二个window来进行大荧幕数据的展示。<br/>
再说说UIScreen对象，对于UIWindow而言，每一个UIWindow中有一个UIScreen对象。UIScreen对象抽象地描述了一个具体显示设备的信息：bounds、mode、brightness等。你也可以监听各种消息，比如连接上显示器了，断开显示器了，显示器亮度调整了等的消息。</p>

<h4>Window和Screen的其他用途</h4>

<p>1、通过UIWindow来调整Window的亮度。还有wantsSoftwareDimming等等。
2、通过UIScreen displayLinkWithTarget:selector: 接口来在runloop进行CoreAnimation每一帧的绘制，或使用OpenGL es直接绘制。</p>

<h4>StoryBoard做了点事情</h4>

<p>使用Storyboard，建立默认的VC。它就帮你做了下面几件事情：</p>

<ul>
<li>Instantiates a window. （初始化Window）</li>
<li>Loads the main storyboard and instantiates its initial view controller. (初始化Storyboard中的initial VC)</li>
<li>Assigns the new view controller to the window’s rootViewController property and then makes the window visible.(把initial VC作为UIWindow中的RootVC，然后让Window可见)</li>
</ul>


<h4>外接显示器的实际做法</h4>

<p>默认的iOS行为：Mirror。如果默认什么都不处理，那么对于一个App而言，它的内容是直接镜像到荧幕上的。除非你要显示和iOS设备荧幕不一样的内容，你可以这样做：</p>

<ul>
<li>程序一启动，就要检查外部显示器的存在。并且注册Screen的连接和断开连接的Notification。</li>
<li>当外部显示器可用了，无论是程序启动检测，还是收到Screen连接的Notification，你都要创建并且配置一个UIWindow给这个外部设备。</li>
<li>连接这个UIWindow和这个合适的UIScreen对象，展示第二个UIWindow，并更新。</li>
</ul>


<p>BTW：如果要开启镜像，请把多出来的UIWindow给干掉就好了。</p>

<h4>代码时间</h4>

<p>好，接下来是代码时间，上面3步的代码如下：<br/>
1、当外部设备Ready的时候，创建一个UIWindow匹配外部抽象的UIScreen对象。</p>

<pre><code>- (void)checkForExistingScreenAndInitializeIfPresent
{
   if ([[UIScreen screens] count] &gt; 1)
  {
     UIScreen *secondScreen = [[UIScreen screens] objectAtIndex:1];
     CGRect screenBounds = secondScreen.bounds;
     self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
     self.secondWindow.screen = secondScreen;
     self.secondWindow.hidden = NO;
  } 
}
</code></pre>

<p>注意：UIWindow最好先和UIScreen连接起来，然后再显示UIWindow的内容，最好不要先显示UIWindow的内容，再链接UIScreen。因为非常耗资源。</p>

<p>2、注册Screen的连接和断开事件</p>

<pre><code> - (void)setUpScreenConnectionNotificationHandlers
{
    NSNotificationCenter *center = [NSNotificationCenter defaultCenter];
    [center addObserver:self selector:@selector(handleScreenDidConnectNotification:) name:UIScreenDidConnectNotification object:nil];
    [center addObserver:self selector:@selector(handleScreenDidDisconnectNotification:)
}
</code></pre>

<p>3、处理断开和连接的事件</p>

<pre><code>- (void)handleScreenDidConnectNotification:(NSNotification*)aNotification
{
   UIScreen *newScreen = [aNotification object];
   CGRect screenBounds = newScreen.bounds;
   if (!self.secondWindow)
   {
    self.secondWindow = [[UIWindow alloc] initWithFrame:screenBounds];
    self.secondWindow.screen = newScreen;
   }
}

- (void)handleScreenDidDisconnectNotification:(NSNotification*)aNotification
{
  if (self.secondWindow)
  {
    // Hide and then delete the window.
    self.secondWindow.hidden = YES;
    self.secondWindow = nil;
  }
}
</code></pre>

<p> 以上代码也可以在水果文档的多屏编码指南中找到。其实这只是一个开始，表明自己Create的UIWindow可以以抽象的方式来在外部显示器上展示，至于不断添加业务逻辑，肯定需要更好的代码封装。最后说一句，水果文档建议在AppDelegate中进行Screen的监听，其实可以按需求来进行工作。大概就这样啦。</p>
]]></content>
  </entry>
  
</feed>

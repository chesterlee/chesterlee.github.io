<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | Chesterfield]]></title>
  <link href="http://chesterlee.github.io/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://chesterlee.github.io/"/>
  <updated>2014-08-24T11:14:24+08:00</updated>
  <id>http://chesterlee.github.io/</id>
  <author>
    <name><![CDATA[chesterlee]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[谈谈iOS中的NSURLProtocol]]></title>
    <link href="http://chesterlee.github.io/blog/2014/08/15/tan-tan-ioszhong-de-nsurlprotocol/"/>
    <updated>2014-08-15T10:23:37+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/08/15/tan-tan-ioszhong-de-nsurlprotocol</id>
    <content type="html"><![CDATA[<p>NSURLProtocol是比较"小众"，但是能量极大的一个东东。在NSHipster中matt对其有详细介绍。</p>

<p>它就像在少林寺里，武功最高的，就是在一旁扫落叶的僧人，默默无闻，你一旦发现他，各种绝学就来了。</p>

<p>&ndash;_-扯远了，我们先看看它是什么，然后看看它能干什么。</p>

<p>1、它的概念：</p>

<p>它是一个抽象类，我们可以通过继承它来定义新的或已存在的URL加载行为。</p>

<p>2、它的功效：</p>

<p>它可以做各种hack的事情：</p>

<ul>
<li><p>拦截获取图片的Request，然后自行加载自己的图片。</p></li>
<li><p>自己拦截特定Request，然后自己做签名，header修改。</p></li>
<li><p>过滤Response、Request中的敏感信息，当然也可以加上敏感信息-0-。</p></li>
<li><p>支持NSURLConnection的callback协议，可以对上层完全透明。</p></li>
</ul>


<p>3、怎么用？</p>

<p>只需要做两件事情：</p>

<p>a、子类化NSURLProtocol类，并注册。APP启动后，但做网络请求之前，就可以干这事情了。后续iOS必然是单例化你的类，然后吃各种callback了。</p>

<p>b、在自己的类的回调上，做一些hack的事情。</p>

<p>4、最简单的sample&hellip;&ndash;_&ndash;</p>

<p>``` objectivec DeriveNSURLProtocol:NSURLProtocol</p>

<pre><code>+ (BOOL)canInitWithRequest:(NSURLRequest*)theRequest
{    
     //自己选择要截获怎样的request，如果要截获就返回YES
     if ([theRequest.URL.scheme caseInsensitiveCompare:@"testapp"] == NSOrderedSame) 
     {        
       return YES;    
     }    
     return NO;
}

+ (NSURLRequest*)canonicalRequestForRequest:(NSURLRequest*)theRequest
{   
    // 正规化自己的request，因为request会用来找对应的cache，默认需要实现该方法，通常不需要修改。
    return theRequest;
}

- (void)startLoading
{    
  //这里就开始加载了，模拟NSURLConnection的callback流程，依次call client的方法来模拟Connection的callback次序
  NSLog(@"%@", request.URL);    
  NSURLResponse *response = [[NSURLResponse alloc] initWithURL:[request URL] MIMEType:@"image/png"  expectedContentLength:-1 textEncodingName:nil];    
  NSString *imagePath = [[NSBundle mainBundle] pathForResource:@"myImage" ofType:@"png"];
  NSData *data = [NSData dataWithContentsOfFile:imagePath];
  [[self client] URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed]; 
  [[self client] URLProtocol:self didLoadData:data];
  [[self client] URLProtocolDidFinishLoading:self];
  [response release];
}

- (void)stopLoading
{    
  //加载结束
  NSLog(@"load over!");
}
</code></pre>

<p>```</p>

<p>5、更多详细介绍可以参看matt的<a href="http://nshipster.com/nsurlprotocol/">http://nshipster.com/nsurlprotocol/</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[谈谈iOS中的HTTP缓存策略]]></title>
    <link href="http://chesterlee.github.io/blog/2014/08/10/ioszhong-de-urlcacheji-zhi/"/>
    <updated>2014-08-10T09:03:05+08:00</updated>
    <id>http://chesterlee.github.io/blog/2014/08/10/ioszhong-de-urlcacheji-zhi</id>
    <content type="html"><![CDATA[<p>iOS中的HTTP URL Cache机制是看上较为简单，但是暗含一些机制的东西。这里将它细化下来。让自己也加深下相应的记忆。</p>

<p>首先，说下概念，HTTP URLCache是HTTP协议中的一部分，用于缓存Response，以达到减轻服务器负担的目的。在iOS中的URL Loading System中，提供了名字叫NSURLCache的类来设置URL缓存的配置信息。</p>

<p>在iOS中的URL缓存容器是共享的，因而我们可以自己继承NSURLCache来配置自己的cache，自定义化它的内存大小，磁盘大小甚至过期时间等等，最后设置为share cache即可。</p>

<p>HTTP缓存在iOS中需要，配合着NSURLRequest的缓存策略来实现的。比如，如果指定了一个Request的缓存策略，那么对应Request就会按既定策略进行处理。策略常用如下：</p>

<ul>
<li><strong>NSURLRequestUseProtocolCachePolicy</strong>。一个Request的默认缓存策略。他是最为隐晦的，我们最后说。</li>
<li><strong>NSURLRequestReturnCacheDataElseLoad</strong>。如果在之前的网络请求中，我们获取了Cache的Response，那么本次请求同样的接口，就直接从Cache中去抓。反之，从服务器上去获取，并在本地cache起来。(这里的问题是，如果cache存在，就一直拉不到服务器数据，所以用这个机制，有它的弊端，当然也要看具体的需求情况。可以通过自定义自类化NSURLCache来自定义cache time，但也仅仅适用于Data改变不大的项目中。)</li>
<li><strong>NSURLRequestReturnCacheDataDontLoad</strong>。只从缓存中获取cached response而不从服务器获取。实属离线版本。</li>
</ul>


<p>好，这里展开说一下相对最为复杂的ProtocolCachePolicy机制：<br/>
1、如果一个Request的NSCachedURLResponse不存在，就去请求网络。<br/>
2、如果一个Request的NSCachedURLResponse存在，就去检查response去决定是否需要刷新。检查Response header的Cache-Control字段是否含有must-revalidated字段(HTTP1.1所带)。<br/>
3、如果包含must-revalidated字段，就通过HEAD方法请求服务器，判断Response头是否有更新，如果有，则去拉数据下来。如果没有，则使用Cache资源。<br/>
4、如果不包含must-revalidated字段，就看看Cache-Control是否包含其他字段，比如max-age等等看看是否过期，如果过期，继续用HEAD去检查Response头，是否为最新数据，如果有则去请求服务器，反之取cache。如果没有过期，则直接取cache。</p>

<ul>
<li>注意：由于HEAD是URL Loading System自身机制，由于没有抓包，所以没去验证。HEAD方法默认使用可以参见水果文档中的Cache Use Semantics for the HTTP Protocol。</li>
</ul>


<p>然后说下通用HTTP的缓存策略：</p>

<p>  HTTP缓存策略中，我们从服务器获取Response后，可以找到(如果有)Response中包含Etag或则Last-Modified字段。当我们做第二次重复请求的时候，可以从CachedURLResponse取出来，把相应字段拼接在HTTPRequestHeader中（例如，IMS，If-Modified-Since配合Last_Modified），然后发送请求，服务端收到后，如果客户端的资源是最新的，那么就会返回304为Response，而不返回任何内容。反之，如果客户端资源落后了，则直接返回200，并返回Data给客户端。</p>

<p>最后谈谈修改NSCachedURLResponse：<br/>
在方法-(NSCachedURLResponse<em>)connection:(NSURLConnection</em>)connectionwillCacheResponse:(NSCachedURLResponse*)cachedResponse中，我们可以对即将缓存的Response进行修改，以达到自己的需求。</p>
]]></content>
  </entry>
  
</feed>
